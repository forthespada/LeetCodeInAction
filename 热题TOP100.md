#### 1、两数之和 已做 





#### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)  不错的题目



给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。

如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

**示例：**

```
输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 0 -> 8
原因：342 + 465 = 807
```

##### 1、想要先把数字求出来再进行计算，然后再保存到数组中，最后转存为链表

链表表示的数字可能会超过int 甚至是long long

~~~C++
 int getNum(ListNode* head) {
	if (head->val == 0) return 0;
	vector<int> result;
	while (head != nullptr) {
		result.push_back(head->val);
		head = head->next;
	}
	int sum = 0;
	for (int i = result.size() - 1; i >= 0; --i)
		sum = sum * 10 + result[i];
	return sum;

}
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
	int sum = getNum(l1) + getNum(l2);
	vector<int> sumV;
    if(sum==0) sumV.push_back(0);
	while (sum != 0) {
		sumV.push_back(sum % 10);
		sum /= 10;
	}
	ListNode* head = new ListNode(sumV[0]);
	ListNode* temp = head;
	for (int i = 1; i <= sumV.size()-1; ++i)
	{
		ListNode* node = new ListNode(sumV[i]);
		temp->next = node;
		temp = temp->next;
	}
	return head;
}
~~~

##### 2、新开辟一条链表来继续数据的保存

执行用时：28 ms, 在所有 C++ 提交中击败了85.88%的用户

内存消耗：9.4 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {


	ListNode* head = new ListNode(l1->val + l2->val);
	ListNode* temp = head;
	l1 = l1->next;
	l2 = l2->next;
	while (l1 != nullptr && l2 != nullptr) {
		ListNode* node = new ListNode(l1->val + l2->val);
		temp->next = node;
		temp = temp->next;
		l1 = l1->next;
		l2 = l2->next;
	}
	temp->next = l1 == nullptr ? l2 : l1;
	temp = head;
	while (temp != nullptr) {
		if (temp->val > 9) {
			if (temp->next != nullptr) {
				temp->val = temp->val - 10;//这里千万注意是减去 10 而不是 9，好好想想
				temp->next->val = temp->next->val + 1;
				
			}
			else {//说明到了最后一个节点了，这种情况很容易忽略。比如999 + 999
				ListNode* node = new ListNode(1); //，最后加出来是 18->18->18，经过前面的处理后 8->9->19，最后一步不好处理了
				temp->val = temp->val -10 ;
				temp->next = node;
				node->next = nullptr;
				break;
			}
		}
		temp = temp->next;
	}
	return head;
}
~~~





##### 3、直接在原内存上操作

执行用时：24 ms, 在所有 C++ 提交中击败了93.11%的用户

内存消耗：8.6 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

	ListNode*pre=nullptr,* head = l1;
	while (l1 != nullptr && l2 != nullptr) {
		l1->val += l2->val;
		pre = l1;//这里注意要用一个pre节点保存尾节点
		l1 = l1->next;
		l2 = l2->next;
	}
	if (l2 != nullptr) {
		pre->next = l2;
	}

	l1= head;
	while (l1 != nullptr) {
		if (l1->val > 9) {
			if (l1->next != nullptr) {
				l1->val = l1->val - 10;
				l1->next->val = l1->next->val + 1;

			}
			else {//说明到了最后一个节点了
				ListNode* node = new ListNode(1);
				l1->val = l1->val - 10;
				l1->next = node;
				node->next = nullptr;
				break;
			}
		}
		l1 = l1->next;
	}
	return head;
}
~~~

其实还有一种改进的方法，那就是将 	if (l2 != nullptr) {
		pre->next = l2;
	}放在最后，因为即使l2还有剩下的，也没有节点值超过10的了，可以先处理合并后的节点，然后再将节点直接连接在后面即可

##### 4、一种更快的神仙做法，我服了

~~~C++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {

	int carry = 0;
	int sum = 0;
	ListNode* newhead = new ListNode(0);
	ListNode* nownode = newhead;
	while (l1 || l2 || carry)//这里条件设置的很好
	{
		sum = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;
		carry = sum / 10;
		ListNode* node = new ListNode(sum % 10);
		nownode->next = node;
		nownode = nownode->next;

		l1 = l1 ? l1->next : l1;
		l2 = l2 ? l2->next : l2;
	}

	return newhead->next;
}
~~~

#### 3、无重复字符的最长子串 已做

#### [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)   不会



给定两个大小为 m 和 n 的正序（从小到大）数组 `nums1` 和 `nums2`。

请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。

你可以假设 `nums1` 和 `nums2` 不会同时为空。

 

**示例 1:**

```
nums1 = [1, 3]
nums2 = [2]

则中位数是 2.0
```

**示例 2:**

```
nums1 = [1, 2]
nums2 = [3, 4]

则中位数是 (2 + 3)/2 = 2.5
```









#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/) 已做

给定一个字符串 `s`，找到 `s` 中最长的回文子串。你可以假设 `s` 的最大长度为 1000。

**示例 1：**

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
```

**示例 2：**

```
输入: "cbbd"
输出: "bb"
```







#### [面试题46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)



给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

 

**示例 1:**

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```



##### 1、跟1-N的数字中统计1出现的个数是差不多的题，需要好好想想，动动笔



执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗：5.8 MB, 在所有 C++ 提交中击败了97.84%的用户



比如0-9只有那一种分法，而10-25之间都是有2中分法的，比如18可以分为 1 + 8 或者直接 18 就可以，所以关键点就是要看十位和个位组成的数字在不在10-25之间。在的话就是2种分法加起来，不在的话比如44，只能分为 4 + 4.有点类似与 [剑指offer中整数n中1出现的数字](https://www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6?tpId=13&&tqId=11184&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)



~~~cpp
    int translateNum(int num) {
        if(num <= 9) return 1;
        int sub = num % 100;//求后两位
        if(sub >= 10 && sub <= 25){//注意 0 -> 'a'，25->‘z’最大就是25了，而不是26
            return translateNum(num / 10) + translateNum(num / 100);
        }else{
            return translateNum(num / 10);
        }

    }

~~~



#### [10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/) 已做



给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
```

所谓匹配，是要涵盖 **整个** 字符串 `s`的，而不是部分字符串。

**说明:**

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `.` 和 `*`。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

**示例 3:**

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

**示例 4:**

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

**示例 5:**

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```



#### [11. 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/) 已做



给你 *n* 个非负整数 *a*1，*a*2，...，*a*n，每个数代表坐标中的一个点 (*i*, *ai*) 。在坐标内画 *n* 条垂直线，垂直线 *i* 的两个端点分别为 (*i*, *ai*) 和 (*i*, 0)。找出其中的两条线，使得它们与 *x* 轴共同构成的容器可以容纳最多的水。

**说明：**你不能倾斜容器，且 *n* 的值至少为 2。

 

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

 

**示例：**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49
```

##### 1、一刷，双指针

执行用时：16 ms, 在所有 C++ 提交中击败了79.22%的用户

内存消耗：7.6 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    int maxArea(vector<int>& height) {
        int low = 0,high = height.size()-1;
        int maxWater = -1;
        while(low  <high){
            int minHeight = min(height[low],height[high]);
            maxWater = max(maxWater,(high-low)*minHeight);
            if(height[low]<=height[high]) low++;
            else
                high--;//想多了，直接比就行
            
        }
        return maxWater;
    }
~~~



##### 二刷：又做错了，哎，总是要向前走的啊，所以直接比较高度就行

执行用时：12 ms, 在所有 C++ 提交中击败了97.26%的用户

内存消耗：7.6 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
int maxArea(vector<int>& height) {

       	int low = 0, high = height.size() - 1;
	int maxWater = INT_MIN;
	while (low < high) {

		int water = (high - low) * min(height[low], height[high]);
		maxWater = max(maxWater, water);

		if (height[low]<= height[high]) low++;
		else
			high--;
	}

	return maxWater;

    }
~~~







#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)



给你一个包含 *n* 个整数的数组 `nums`，判断 `nums` 中是否存在三个元素 *a，b，c ，*使得 *a + b + c =* 0 ？请你找出所有满足条件且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

 

**示例：**

```
给定数组 nums = [-1, 0, 1, 2, -1, -4]，

满足要求的三元组集合为：
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```

##### 1、暴力法，超时了

~~~C++
    vector<vector<int>> threeSum(vector<int>& nums) {

	int len = nums.size();
	if (len < 3) return vector<vector<int>>();
	vector<vector<int>> result;
	vector<int> temp(3);
	set<pair<int, pair<int, int>>> unique;
	for (int i = 0; i < len; ++i) {
		for (int j = i + 1; j < len; ++j) {
			for (int k = j + 1; k < len; ++k)
				if (nums[i] + nums[j] + nums[k] == 0) {

					temp[0] = nums[i];
					temp[1] = nums[j];
					temp[2] = nums[k];
					sort(temp.begin(),temp.end());
					if (unique.count(make_pair(temp[0], make_pair(temp[1], temp[2])))==0)
						{
                            result.push_back(temp);
                            unique.insert(make_pair(temp[0], make_pair(temp[1], temp[2])));
                        }
				}
		}
	}
	return result;

    }
~~~

##### 2、排序 + 双指针，效果不太行

执行用时：204 ms, 在所有 C++ 提交中击败了14.44%的用户

内存消耗：20 MB, 在所有 C++ 提交中击败了7.60%的用户

~~~C++
vector<vector<int>> threeSum(vector<int>& nums) {

	sort(nums.begin(), nums.end()); //排序
	vector<vector<int>> res; //定义输出
	for (int i = 0; i < int(nums.size() - 2) && nums[i] <= 0; i++) {//如果当前数字大于0，则三数之和一定大于0，结束循环，有可能是0 0 0这样的排序，所以是<=0
		if (i > 0 && nums[i] == nums[i - 1]) continue; // (i > 0)防止越界
		int j = i + 1, k = nums.size() - 1;
		while (j < k && nums[k] >= 0) { //如果nums[k] < 0，则三数之和一定小于0.结束循环
			if (nums[j] + nums[k] == -nums[i]) {
				res.push_back({ nums[i], nums[j], nums[k] });
				while (j < k && nums[j] == nums[j + 1]) j++;
				while (j < k && nums[k] == nums[k - 1]) k--;
				j++, k--;
			}
			else if (nums[j] + nums[k] < -nums[i]) j++;
			else k--;
		}
	}
	return res;


}
~~~

一些经典问答：

大佬，我觉得搜到倒数第三个就可以停了，于是写了，定义判断时候for (int i = 0; i < nums.size() -2; i ++)，但是这样会报越界；for (int i = 0; i < nums.size() ; i ++)就不会，大佬知道为什么吗，跪求



因为size()和length()返回的是无符号整数形(unsigned int)，所以当size() - 2，也就说输入为空时，因为size()返回的是无符号类型，所以size() - 2不会等于- 2，会报错，也就是越界，所以需要强制转换，不知道我说清楚了吗？





##### 更改一点代码：

~~~C++
	int len = nums.size();
	if (len < 3) return vector<vector<int>>();
	sort(nums.begin(), nums.end()); //排序
	vector<vector<int>> res; //定义输出
	for (int i = 0; i < len-2 && nums[i] <= 0; i++) {//如果当前数字大于0，则三数之和一定大于0，结束循环，有可能是0 0 0这样的排序，所以是<=0
		if (i > 0 && nums[i] == nums[i - 1]) continue; // (i > 0)防止越界
		int j = i + 1, k = nums.size() - 1;
		while (j < k && nums[k] >= 0) { //如果nums[k] < 0，则三数之和一定小于0.结束循环
			if (nums[j] + nums[k] == -nums[i]) {
				res.push_back({ nums[i], nums[j], nums[k] });
				while (j < k && nums[j] == nums[j + 1]) j++;
				while (j < k && nums[k] == nums[k - 1]) k--;
				j++, k--;//看清楚上面一步，是 j = j+1 和 k = k-1 所以要跳过当前数字，还需要最后一步
			}
			else if (nums[j] + nums[k] < -nums[i]) j++;
			else k--;
		}
	}
	return res;
~~~



##### 3、借助sum保存结果，可以减少时间

执行用时：100 ms, 在所有 C++ 提交中击败了70.29%的用户

内存消耗：19.6 MB, 在所有 C++ 提交中击败了7.60%的用户

~~~C++
    vector<vector<int>> threeSum(vector<int>& nums) {

        	int len = nums.size();
	if (len < 3) return vector<vector<int>>();
	sort(nums.begin(), nums.end()); //排序
	vector<vector<int>> res; //定义输出
	for (int i = 0; i < len-2 && nums[i] <= 0; i++) {//如果当前数字大于0，则三数之和一定大于0，结束循环，有可能是0 0 0这样的排序，所以是<=0
		if (i > 0 && nums[i] == nums[i - 1]) continue; // (i > 0)防止越界
		int j = i + 1, k = nums.size() - 1;
		while (j < k && nums[k] >= 0) { //如果nums[k] < 0，则三数之和一定小于0.结束循环
			int sum = nums[j] + nums[k] + nums[i];
			if (sum==0) {
				res.push_back({ nums[i], nums[j], nums[k] });
				while (j < k && nums[j] == nums[j + 1]) j++;
				while (j < k && nums[k] == nums[k - 1]) k--;
				j++, k--;//看清楚上面一步，是 j = j+1 和 k = k-1 所以要跳过当前数字，还需要最后一步
			}
			else if (sum<0) j++;
			else k--;
		}
	}
	return res;

    }
~~~

##### 二刷：

执行用时：80 ms, 在所有 C++ 提交中击败了93.69%的用户

内存消耗：19.6 MB, 在所有 C++ 提交中击败了7.60%的用户

~~~C++
 vector<vector<int>> threeSum(vector<int>& nums) {

    int len = nums.size();
	if (len < 3) return vector<vector<int>>();
	vector<vector<int>> result;
	sort(nums.begin(), nums.end());
	for (int i = 0; i < len - 2 && nums[i] <= 0; ++i) {
		if (i>0 && nums[i] == nums[i - 1]) continue;//注意这里需要是i 与 i-1，比较，即遇到第一个元素就进行比较了
		int low = i + 1, high = len - 1;
		while (low < high) {
			int sum = nums[i] + nums[low] + nums[high];
			if (sum < 0) low++;
			else if (sum > 0) high--;
			else {//等于0
				result.push_back({ nums[i],nums[low],nums[high] });
				while(low < high&& nums[low] == nums[low + 1]) ++low;
				while(low < high&& nums[high] == nums[high - 1]) --high;
				++low, --high;

			}
		}

	}
    return result;

    }
~~~









#### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)  已做



给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png)

**示例:**

```
输入："23"
输出：["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
```

**说明:**
尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。



#### [18. 四数之和](https://leetcode-cn.com/problems/4sum/)



给定一个包含 *n* 个整数的数组 `nums` 和一个目标值 `target`，判断 `nums` 中是否存在四个元素 *a，**b，c* 和 *d* ，使得 *a* + *b* + *c* + *d* 的值与 `target` 相等？找出所有满足条件且不重复的四元组。

**注意：**

答案中不可以包含重复的四元组。

**示例：**

```
给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。

满足要求的四元组集合为：
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```



##### 1、转化为三数之和，然后再转化为两数之和来做，注意去重

执行用时：40 ms, 在所有 C++ 提交中击败了85.26%的用户

内存消耗：7.3 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int len = nums.size();
        if(len<=3) return vector<vector<int>>();
        sort(nums.begin(),nums.end());//首先排序
         vector<vector<int>> result;
        for( int i  = 0; i <= len-4;  ++i ){
               if(i!=0 && nums[i] == nums[i-1] ) continue;//去重

               int newTarget = target - nums[i];//四数之和转化为三数之和
               for(int j = i+1 ; j<= len-3 ; ++j ){
                   if( j != i+1 && nums[j] == nums[j-1]) continue;//去重

                    int newTarget2 = newTarget-nums[j], low = j+1,high = len-1;//三数之和转化为两数之和
                    while(low<high){

                        int sum = nums[low] + nums[high];
                        if(sum == newTarget2 ) 
                        {
                            result.push_back({nums[i], nums[j], nums[low], nums[high]});
                            while(low<high && nums[low] == nums[low + 1]) low++;
                            while(low<high && nums[high] == nums[high - 1]) high--;
                            low++,high--;
                        }else if(sum > newTarget2 ) --high;
                        else
                            ++low;
                    }
               }
        }
        return result;

    }
~~~

##### 2、再次优化，真的很厉害了，按理说应该是会更快一点啊，奇怪

执行用时：72 ms, 在所有 C++ 提交中击败了75.34%的用户

内存消耗：7.2 MB, 在所有 C++ 提交中击败了100.00%的用户



~~~cpp
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        int len = nums.size();
        if(len<=3) return vector<vector<int>>();
        sort(nums.begin(),nums.end());//首先排序
         vector<vector<int>> result;
        for( int i  = 0; i <= len-4;  ++i ){
               if(i!=0 && nums[i] == nums[i-1] ) continue;//去重

               int newTarget = target - nums[i];//四数之和转化为三数之和
               for(int j = i+1 ; j<= len-3 ; ++j ){

                   if( j != i+1 && nums[j] == nums[j-1]) continue;//去重

                    int newTarget2 = newTarget-nums[j], low = j+1,high = len-1;//三数之和转化为两数之和
                    while(low<high){

                        int sum = nums[low] + nums[high];
                        if(sum == newTarget2 ) 
                        {
                            result.push_back({nums[i], nums[j], nums[low], nums[high]});
                            while(low<high && nums[low] == nums[low + 1]) low++;//注意优化
                            while(low<high && nums[high] == nums[high - 1]) high--;//注意优化
                            low++,high--;
                        }else if(sum > newTarget2 ) {
                             while(low<high && nums[high] == nums[high - 1]) high--;//再次优化
                            --high;
                            }
                        else
                          
                            {

                            while(low<high && nums[low] == nums[low + 1]) low++;//再次优化
                            ++low;
                            }
                    }

               }

        }
        return result;
    }
~~~







#### [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

给定一个链表，删除链表的倒数第 *n* 个节点，并且返回链表的头结点。

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 n = 2.

当删除了倒数第二个节点后，链表变为 1->2->3->5.
```

**说明：**

给定的 *n* 保证是有效的。

**进阶：**

你能尝试使用一趟扫描实现吗？



##### 1、常规做法，首先遍历一次，求出总次数，然后删除倒数第n个

执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗：6.5 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
 ListNode* removeNthFromEnd(ListNode* head, int n) {
	ListNode* headTemp = head,*pre=head;
	int len = 0;
	while (headTemp != nullptr) {
		len++;
		headTemp = headTemp->next;
	}
	if (len == n) return head->next;//有可能删除的是首节点
	n = len - n + 1;//这里要注意加1
	headTemp = head;
	while (--n) {
		pre = head;
		head = head->next;
	}
	pre->next = head->next;
	return headTemp;
    }
~~~



##### 2、一次遍历的做法，保持一个n+1的队列来做

执行用时：4 ms, 在所有 C++ 提交中击败了92.38%的用户

内存消耗：7 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
ListNode* removeNthFromEnd(ListNode* head, int n) {
	queue<ListNode*>q;
	ListNode* headTemp = head,*node=NULL;
	while (headTemp != nullptr) {
		q.push(headTemp);
		headTemp = headTemp->next;
		while (q.size() > n + 1) {
			q.pop();
		}
	}
	if (q.size() == n + 1) {
		node = q.front();
		q.pop();
		headTemp = q.front();
		node->next = headTemp->next;
		return head;
	}
	else {//说明一共还没有 n+1个节点，又因为n是有效的,所以最多n个节点了，也就是删除头节点直接返回头节点的下一个节点
		return head->next;
	}

~~~

##### 3、快慢指针，更快的做法

执行用时：4 ms, 在所有 C++ 提交中击败了92.38%的用户

内存消耗：6.5 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
    ListNode* removeNthFromEnd(ListNode* head, int n) {
	ListNode* fast = head;
	while (n--) {
		fast = fast->next;
	}
	if (fast == nullptr) return head->next;//删除的是头节点
	ListNode* slow = head;
	while (fast->next != nullptr) {
		slow = slow->next;
		fast = fast->next;
	}
	slow->next = slow->next->next;
	return head;

    }
~~~

#### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)  好好看看内存不会泄露的版本



将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

 

**示例：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```







##### 1、这种写法比较繁琐



~~~cpp
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    if (l1 == nullptr) return l2;
	if (l2 == nullptr)  return l1;

	ListNode* res=nullptr;

	if (l1->val <= l2->val) {

		res = l1;
		l1 = l1->next;

	}
	else {

		res = l2;
		l2 = l2->next;
	}

	ListNode* head = res;

	while (l1 && l2) {
		if (l1->val <= l2->val) {

			res->next = l1;		
			l1 = l1->next;
			res = res->next;

		} else {
			res->next = l2;
			l2 = l2->next;
			res = res->next;
		}

	}

	res->next = l1 == nullptr ? l2 : l1;
	return head;
        
    }
~~~



##### 2、迭代的简单一点的写法，但是会造成内存泄漏

元素是开辟在堆区的，这里也没有进行内存释放



~~~cpp
    ListNode* mergeTwoLists(ListNode* a, ListNode* b) {
        if(!a) return b;
        if(!b) return a;
        ListNode* ph = new ListNode(-1);
        ListNode* pt = ph;  //都是同一个地址 next有值了 ph也就挂上了
        while(a && b){ //两个都不为空
            if(a->val < b->val){
                pt->next = a;   //指向a
                a = a->next;      //下移
            }else{
                pt->next = b;   //指向b
                b = b->next;      //下移
            }
            pt = pt->next;  //下移
        }   //有的空了 后面直接挂
        pt->next = (a==nullptr) ? b:a;
        return ph->next;
    }
~~~

##### 3、安全版本，避免内存泄露，将元素开辟在堆区

执行用时：4 ms, 在所有 C++ 提交中击败了99.14%的用户

内存消耗：14.3 MB, 在所有 C++ 提交中击败了5.61%的用户

~~~cpp
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode newHead(0);
	ListNode* pi = &newHead;
	while (l1 != nullptr && l2 != nullptr ) {
		if (l1->val > l2->val) swap(l1, l2);//始终让 l1的值更小一点
		pi->next = l1;
		l1 = l1->next;
		pi = pi->next;
	}
	pi->next = l1 ? l1 : l2;
	return newHead.next;//注意这种写法 其实跟 （*l1）.next是差不多的写法
    }

~~~

###### 3-1，常规写法，这种写法才是我能够想到的



~~~cpp
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
	ListNode newHead(0);
	ListNode* pi = &newHead;
	while (l1 != nullptr && l2 != nullptr ) {
		if (l1->val > l2->val) { 
			pi->next = l2;
			l2 = l2->next;
		}
		else {
			pi->next = l1;
			l1 = l1->next;
		}
		pi = pi->next;
	}
	pi->next = l1 != nullptr ? l1 : l2;
	return newHead.next; //注意这种写法 其实跟 （*l1）.next是差不多的写法
    }
~~~









#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

数字 *n* 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

**示例：**

```
输入：n = 3
输出：[
       "((()))",
       "(()())",
       "(())()",
       "()(())",
       "()()()"
     ]
```



##### 1、递归做法

执行用时：4 ms, 在所有 C++ 提交中击败了90.01%的用户

内存消耗：11.7 MB, 在所有 C++ 提交中击败了81.40%的用户

~~~C++
void generateParenthesisCore(int n, int left, int right, string str, vector<string>& result) {
	if (left > n || right > n) return;//注意设置条件
	if (left == n && right == n - 1) { 
		result.push_back(str + ')'); 
		return; 
	}
	if (right > left) return;
	generateParenthesisCore(n, left + 1, right, str+'(', result);
	generateParenthesisCore(n, left , right+1, str +')', result);

}

vector<string> generateParenthesis(int n) {
	int left = 0, right = 0;
	vector<string> result;
	string str = "(";
	generateParenthesisCore(n, 1, 0, str, result);
	return result;
}
~~~

##### 2、递归 + 剪枝，按理说是应该快一些的

执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗：11.6 MB, 在所有 C++ 提交中击败了81.40%的用户

~~~C++
void generateParenthesisCore(int n, int left, int right, string &str, vector<string>& result) {
	if (left > n || right > n || right>left) return;//注意设置条件
	if (left == n && right == n - 1) {
		result.push_back(str + ')');
		return;
	}
	str.push_back('(');
	generateParenthesisCore(n, left + 1, right, str, result);
	str.pop_back();//记得要pop出去
	str.push_back(')');
	generateParenthesisCore(n, left, right + 1, str, result);
	str.pop_back();//这里也一样，要pop出去的
	return;
}

vector<string> generateParenthesis(int n) {
	int left = 0, right = 0;
	vector<string> result;
	string str = "(";
	generateParenthesisCore(n, 1, 0, str, result);
	return result;
}
~~~





#### [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

合并 *k* 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

**示例:**

```
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6
```



##### 1、二路归并 + 链表合并

执行用时：32 ms, 在所有 C++ 提交中击败了92.50%的用户

内存消耗：9.9 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
ListNode* mergeTwoLists(ListNode* head1, ListNode* head2) {
	if (head1 == nullptr) return head2; //链表有可能为空，比如 [[],[]]或者 [[1],[],[-2]]
	if (head2 == nullptr) return head1;
	ListNode* head = NULL, * node = NULL;//注意这里的预处理，两个有序链表的合并是需要掌握的
	if (head1->val < head2->val) {
		node = head1;
		head1 = head1->next;
	}
	else
	{
		node = head2;
		head2 = head2->next;
	}
	head = node;
	head->next = node;
	while (head1 != nullptr && head2 != nullptr) {
		if (head1->val <= head2->val) {
			node->next = head1;
			node = node->next;
			head1 = head1->next;
		}
		else
		{
			node->next = head2;
			node = node->next;
			head2 = head2->next;
		}
		//cout << node->val << endl;

	}
	node->next = head1 == nullptr ? head2 : head1;
	return head;
}


ListNode* mergeKLists(vector<ListNode*>& lists) {
	int len = lists.size();
	if (len == 0) return nullptr;
	if (len == 1) return lists[0];
	while (len != 1) {
		int index = 0;
		if (len % 2 == 0)
		{
			for (int i = 0; i < len - 1; i += 2) {
				lists[index++] = mergeTwoLists(lists[i], lists[i + 1]);
			}
		}
		else {
			for (int i = 0; i < len - 2; i += 2) {
				lists[index++] = mergeTwoLists(lists[i], lists[i + 1]);
			}
			lists[index++] = lists[len - 1];

		}
		len = index;
	}
	return lists[0];
}
~~~



##### 2、借助优先队列来做，很好的方法，一个大顶堆 greator <int> ,默认输出最小的元素

执行用时：36 ms, 在所有 C++ 提交中击败了83.46%的用户

内存消耗：10.5 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
struct compare {
	bool operator()(ListNode* node1, ListNode* node2)
	{
		return node1->val > node2->val;
	}
};

class Solution {
public:


	ListNode* mergeKLists(vector<ListNode*>& lists) {
		int len = lists.size();
		if (len == 0) return nullptr;
		if (len == 1) return lists[0];
		priority_queue<int, vector<ListNode*>, compare> pq;

		for (auto node : lists) {
			if (node != nullptr)
			{
				pq.push(node);
			}
		}
		ListNode* head = new ListNode(0);
		ListNode* cur = head, * node = NULL;
		while (!pq.empty()) {
			node = pq.top();
			pq.pop();
			cur->next = node;
			cur = cur->next;
			if (node->next != nullptr) pq.push(node->next);
		}
		return head->next;
	}
};
~~~





#### [31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)   好题

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须**原地**修改，只允许使用额外常数空间。

以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
`1,2,3` → `1,3,2`
`3,2,1` → `1,2,3`
`1,1,5` → `1,5,1`





题干的意思是：找出这个数组排序出的所有数中，刚好比当前数大的那个数

比如当前 nums = [1,2,3]。这个数是123，找出1，2，3这3个数字排序可能的所有数，排序后，比123大的那个数 也就是132

如果当前 nums = [3,2,1]。这就是1，2，3所有排序中最大的那个数，那么就返回1，2，3排序后所有数中最小的那个，也就是1，2，3 -> [1,2,3]





##### 1、调库函数 next_permutation



~~~C++
    void nextPermutation(vector<int>& nums) {
    next_permutation(nums.begin(),nums.end()); 
    }
~~~



##### 2、第二种方法

思路很简单吧，主要用到三个方法，swap,sort,reverse。
先判断，从后往前找到合适一位。
再swap。
然后对于后面的数进行排序。
如果找不到，就把整个vector进行reverse

执行用时：20 ms, 在所有 C++ 提交中击败了15.85%的用户

内存消耗：12.2 MB, 在所有 C++ 提交中击败了6.67%的用户

~~~C++
    void nextPermutation(vector<int>& nums) {

	int len = nums.size() - 1;
	if (len < 1) return;
	while (len > -1) {
		int high = nums.size() - 1;
		while (high > len)
		{
			if (nums[high] > nums[len]) {
				swap(nums[len], nums[high]);
				sort(1 + len + nums.begin(), nums.end());
				return;
			}
			high--;
		}
		len--;
	}
	reverse(nums.begin(), nums.end());
    
    }
~~~

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) 挺好的题目



假设按照升序排序的数组在预先未知的某个点上进行了旋转。

( 例如，数组 `[0,1,2,4,5,6,7]` 可能变为 `[4,5,6,7,0,1,2]` )。

搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 `-1` 。

你可以假设数组中不存在重复的元素。

你的算法时间复杂度必须是 *O*(log *n*) 级别。

**示例 1:**

```
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4
```

**示例 2:**

```
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1
```

##### 1、自己写的太麻烦了

~~~cpp
    int search(vector<int>& nums, int target) {

	int len = nums.size() - 1, low = 0, high = len;
	if (len < 0) return -1;
    if( len == 0) return nums[0]==target?0:-1;
	while (low + 1 < high) {
		int mid = low + (high - low) / 2;
		if (nums[mid] > nums[low]) low = mid;
		else if (nums[mid] < nums[high]) high = mid;
	}

	int minIndex = nums[low] < nums[high] ? low : high;
	if (target >= nums[0]) //在左侧
	{
		low = 0, high = minIndex-1;
		while (low + 1 < high) {
			int mid = low + (high - low) / 2;
			if (target == nums[mid]) return mid;
			else if (nums[mid] > target) high = mid;
			else
				low = mid;
		}
		if (nums[low] == target) return low;
        if (high>=0 && nums[high] == target) return high;

	}
	else //在右侧
	{
		low = minIndex, high = len;
		while (low + 1 < high) {
			int mid = low + (high - low) / 2;
			if (target == nums[mid]) return mid;
			else if (nums[mid] > target) high = mid;
			else
				low = mid;
		}
		if (nums[low] == target) return low;
		if (nums[high] == target) return high;

	}
	return -1;

    }
~~~



##### 2、简单一点的写法

执行用时：4 ms, 在所有 C++ 提交中击败了66.00%的用户

内存消耗：6.5 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
    int search(vector<int>& nums, int target) {

	int len = nums.size(), left = 0, right = len - 1;;
	if (len == 0) return -1;//这步判断必不可少
	while (left +1 < right) {
		int mid = left + ( right - left) / 2;
		if (nums[mid] == target)
			return mid;
		else if (nums[mid] < nums[right]) {
			if (nums[mid] < target && target <= nums[right])
				left = mid;
			else
				right = mid;
		}
		else {
			if (nums[left] <= target && target < nums[mid])
				right = mid;
			else
				left = mid ;
		}
	}
	if (nums[left] == target) return left;
	if (nums[right] == target) return right;
	return -1;

    }
~~~



##### 3、二分法第二种写法

执行用时：4 ms, 在所有 C++ 提交中击败了66.00%的用户

内存消耗：6.4 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    int search(vector<int>& nums, int target) {

	int len = nums.size(), left = 0, right = len - 1;;
	if (len == 0) return -1;
	while (left  <= right) {
		int mid = left + ( right - left) / 2;
		if (nums[mid] == target)
			return mid;
		else if (nums[mid] < nums[right]) {
			if (nums[mid] < target && target <= nums[right])
				left = mid +1 ;
			else
				right = mid -1;
		}
		else {
			if (nums[left] <= target && target < nums[mid])
				right = mid -1;
			else
				left = mid +1 ;
		}
	}

	return -1;

    }
~~~



##### 4、递归写法

执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗：6.5 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
int searchCore(vector<int>& nums, int target, int low, int high) {
	if (low > high || low < 0 || high >= nums.size()) return -1;
	int mid = low + (high - low) / 2;
	if (nums[mid] == target) return mid;
	
	if (nums[mid] < nums[high])//右侧升序
	{
		if (nums[mid] <target && nums[high] >=target) //落在右边
			return searchCore(nums, target, mid +1, high);
		else
			return searchCore(nums, target, low , mid -1 );//落在左边
	}
	else {//左侧升序

		if (nums[mid] > target && nums[low]<=target)
			return searchCore(nums, target, low, mid-1);//落在右边
		else
			return searchCore(nums, target, mid+1 ,high);//落在左边
	}

	return -1;


}


int search(vector<int>& nums, int target) {
	int len = nums.size();
	if (len == 0)  return -1;
	return searchCore(nums, target, 0, len - 1);
}

~~~





##### 二刷1：

~~~cpp
int search(vector<int>& nums, int target) {
	int len = nums.size();
	if (len == 0)  return -1;
	int low = 0, high = len - 1;
	while (low <= high) {
		int mid = low + (high - low) /2;;
		if (nums[mid] == target) return mid;
		if (nums[mid] >= nums[low]) //左边有序,最好还是先判断右侧的比较好一点
			//当数组只有两个元素的时候 比如 3 1 这种情况会走到第二个else里面 这时候数组长度为偶数，
			//如果中值取得是前面就会漏掉后面这个元素的判断
		{
			if (nums[low] <= target && nums[mid] > target)
				high = mid - 1;
			else
				low = mid + 1;
		}
		else {//右边有序
			if (nums[high] >= target && nums[mid] < target)
				low = mid + 1;
			else
				high = mid - 1;
		}

	}
	return -1;
}
~~~

二刷2：

执行用时：4 ms, 在所有 C++ 提交中击败了65.86%的用户

内存消耗：6.5 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~c++
int search(vector<int>& nums, int target) {
	int len = nums.size();
	if (len == 0)  return -1;
	int low = 0, high = len - 1;
	while (low <= high) {
		int mid = low + (high - low) /2;;
		if (nums[mid] == target) return mid;
		if (nums[mid] < nums[high]) //右边有序
		{
			if (nums[high] >= target && nums[mid] < target)
				low = mid + 1;
			else
				high = mid - 1;
		}
		else {
			if (nums[low] <= target && nums[mid] > target)
				high = mid - 1;
			else
				low = mid + 1;
		}

	}
	return -1;
}
~~~

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)



给定一个**无重复元素**的数组 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的数字可以无限制重复被选取。

**说明：**

- 所有数字（包括 `target`）都是正整数。
- 解集不能包含重复的组合。 

**示例 1:**

```
输入: candidates = [2,3,6,7], target = 7,
所求解集为:
[
  [7],
  [2,2,3]
]
```

**示例 2:**

```
输入: candidates = [2,3,5], target = 8,
所求解集为:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```



##### 1、经典回溯模板

执行用时：8 ms, 在所有 C++ 提交中击败了83.99%的用户

内存消耗：7.7 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
void combinationSumCore(vector<vector<int>>& res, vector<int>& candidates, int target, vector<int>& tmp, int sum, int begin) {
	if (sum == target) {
		res.push_back(tmp);
	}
	else {
		for (int i = begin; i < candidates.size(); ++i) {
			if (sum + candidates[i] <= target) {
				tmp.push_back(candidates[i]);
				combinationSumCore(res, candidates, target, tmp, sum + candidates[i], i);
				tmp.pop_back();
			}else{
				return;
			}
		}
	}
}

vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
	vector<vector<int>> res;
	vector<int> tmp;
	sort(candidates.begin(), candidates.end());
	combinationSumCore(res, candidates, target, tmp, 0, 0);//sum 与 index
	return res;

}
~~~



#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 **感谢 Marcos** 贡献此图。

**示例:**

```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```



##### 1、超时了，思路应该没问题

将height一层一层的处理

~~~cpp
   void trapHelp(vector<int>&height){
        for(int i=0;i<height.size();++i)
            if(height[i]>0)
                height[i] = height[i]-1;
    }

    int trap(vector<int>& height) {
        int len = height.size();
        if(len<=1) return 0;
        int maxHeight = *max_element(height.begin(),height.end());
        int trap=0;
        for(int i=0;i<=maxHeight;++i){
            int low=0;
            while(low<len && height[low]==0) low++;//找到第一个不为0的数字
            if(low==0) break;
            int high=low+1;
            while(high<len){
                if(height[high]!=0) {
                    if(high-low!=1) {
                        trap +=high-low-1;
                    }
                    low = high;
                }
                high++;
            }
            trapHelp(height);
        }
    return trap;
    }
~~~

##### 2、服气，真的厉害，画画图就知道了

执行用时：4 ms, 在所有 C++ 提交中击败了94.84%的用户

内存消耗：7.1 MB, 在所有 C++ 提交中击败了100.00%的用户



最后的for循环，i=0和i=n-1都可以不用判断了，level一定是0//因为left[0] 和 right[n-1]都是0，所以level也是0，自然 max(0,level-height[i])也是0了



对于vector中每个点，水有多高取决于这个点左侧和右侧墙壁的最大高度。第一个for循环找每个点的左侧最大高度，第二个for循环找每个点右侧的最大高度，循环中跳过最左侧(i=0)和最右侧点(i=vector.size()-1)的原因是这两个点由于没有左侧墙壁或右侧墙壁所以最大墙壁高度肯定是0，故在初始化vector的时候已经将其默认设置成0了。在得到所有点的左右墙壁最大高度后，木桶原理取左右墙壁较低的那个高度减去当前位置墙壁作为地面的高度就得到了这个位置上水的高度。然后将所有点的水高度相加即为解。



~~~cpp
 int trap(vector<int>& height) {
	int n = height.size();
	if (n <= 2) return 0;
	// left[i]表示i左边的最大值，right[i]表示i右边的最大值
	vector<int> left(n,0), right(n,0);
	for (int i = 1; i < n; i++) {
		left[i] = max(left[i - 1], height[i - 1]);
	}
	//for (int i = 0; i < n; ++i) {
	//	cout << i << " " << left[i] << endl;
	//}
	// cout << endl;
	for (int i = n - 2; i >= 0; i--) {
		right[i] = max(right[i + 1], height[i + 1]);
	}
	//for (int i = 0; i < n; ++i) {
	//	cout << i << " " << right[i] << endl;
	//}
	//cout << endl;

	int water = 0;
	for (int i = 0; i < n; i++) {
		int level = min(left[i], right[i]);
		water += max(0, level - height[i]);
	}
	return water;
    }
~~~



##### 3、最快的方法找到最高的那个点向两边逐渐扩散

下一个比它低的就能接到水，依次保存左右两边的最大值即可

虽然不太好理解，画个图就知道了

执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗：6.9 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    int trap(vector<int>& height) {
	int n = height.size();
	if (n <= 2) return 0;
	int maxHeight = 0, index = 0;
	for (int i = 0; i < n; ++i) {//找到最高的那个高度和index开始循环
		if (height[i] > maxHeight) {
			maxHeight = height[i];
			index = i;
		}
	}
	int water = 0;
	maxHeight = height[0];
	for (int i = 1; i <index; ++i) {//从0开始会浪费一次时间，下面也是的
		if (maxHeight < height[i])
			maxHeight = height[i];
		else
			water += maxHeight - height[i];
	}
	maxHeight = height[n - 1];
	for (int i = n-2; i > index; --i) {
		if (maxHeight < height[i])
			maxHeight = height[i];
		else
			water += maxHeight - height[i];
	}
	return water;
    }
~~~

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)



给定一个 *n* × *n* 的二维矩阵表示一个图像。

将图像顺时针旋转 90 度。

**说明：**

你必须在**原地**旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要**使用另一个矩阵来旋转图像。

**示例 1:**

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```





##### 1、首先上下旋转，再左右旋转

执行用时：4 ms, 在所有 C++ 提交中击败了59.96%的用户

内存消耗：7.3 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    void rotate(vector<vector<int>>& matrix) {
        int len=matrix.size();
        if(len<=1) return;      
        for(int i = 0;i < len / 2;++i)
        {
            swap(matrix[i],matrix[len - 1 - i]);
        }
        
        for(int i = 0;i < len;++i)
        {
            for(int j = 0;j < i;++j)
            {
                swap(matrix[i][j],matrix[j][i]);
            }
        }
        
    }
~~~

##### 二刷：

~~~c++
    void rotate(vector<vector<int>>& matrix) {
        int len = matrix.size();
        if(len<=1 ) return;
        for(int i=0;i<len/2;++i)
            swap(matrix[i],matrix[len-i-1]);
        
        for(int i=0; i<len;++i){
            for(int j=i+1;j<len;++j){
                // if(i==j) continue;
                swap(matrix[i][j],matrix[j][i]);
            }
        }

    }
~~~







#### [49. 字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)



给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

**示例:**

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明：**

所有输入均为小写字母。

不考虑答案输出的顺序。

##### 1、哈希映射关系的一种做法

执行用时：96 ms, 在所有 C++ 提交中击败了38.49%的用户

内存消耗：16.4 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~c++
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

	vector<string> temp(strs.begin(), strs.end());
	//unordered_set<string> unset;
	multimap<string, int> unmp;
	int len = strs.size();
	for (int i = 0; i < len; ++i) 
	{
		sort(temp[i].begin(), temp[i].end());
		unmp.insert({temp[i],i});//temp[i]唯一，但是 int 并不唯一
	}

	vector<vector<string>> res;
	for (auto beg = unmp.begin(); beg != unmp.end(); ) {//注意multimap<string, int>的遍历方法
		vector<string> strTemp;
		int size = unmp.count(beg->first);
		while (size--) {
			strTemp.emplace_back(strs[beg->second]);
			++beg;
		}
		res.push_back(strTemp);
	}

	return res;
    }
~~~



##### 2、使用unordered_map<sstring,vector<string>> 会更快一点

执行用时：68 ms, 在所有 C++ 提交中击败了80.78%的用户

内存消耗：16.2 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    vector<vector<string>> groupAnagrams(vector<string>& strs) {

	unordered_map<string, vector<string>> unmp;
	int len = strs.size();
	for (int i = 0; i < len; ++i) 
	{
		string key = strs[i];
		sort(key.begin(),key.end());
		unmp[key].emplace_back(strs[i]);
	}

	vector<vector<string>> res;
	for (auto beg = unmp.begin(); beg != unmp.end(); ++beg) {
		res.emplace_back(beg->second);
	}
	return res;
    }
~~~





##### 二刷：使用emplace_back + std::move函数会快上不少

执行用时：60 ms, 在所有 C++ 提交中击败了95.41%的用户

内存消耗：15.3 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string,vector<string>> unmp;
        for(auto &a:strs){
            string temp(a.begin(),a.end());
            sort(temp.begin(),temp.end());
            unmp[temp].push_back(a);
        }
        vector<vector<string>> res;
        for(auto it=unmp.begin();it!=unmp.end();++it){
            res.emplace_back(std::move(it->second));//emplac_back + move
        }
        return res;
    }
~~~





#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)



给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

**示例 1:**

```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

**示例 2:**

```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```



##### 1、贪心策略

贪心算法，每个位置都计算自己能达到的最远距离，同时每个位置要判断自己是否可达，也就是本位置需要在当前最远能到达的距离中。最终计算出来能到达的最远距离，与数组长度比较即可。

~~~c++
 bool canJump(vector<int>& nums) {
        int len = nums.size();
        if (len <= 1) return true;

        int maxDis = nums[0];

        for (int i = 1; i < len - 1; i++) {
            if (i <= maxDis) {
                maxDis = max(maxDis, nums[i]+i);
            }
        }

        return maxDis >= len - 1;
    }
~~~



执行用时：24 ms, 在所有 C++ 提交中击败了32.44%的用户

内存消耗：13 MB, 在所有 C++ 提交中击败了8.70%的用户

~~~cpp
    bool canJump(vector<int>& nums) {
        int can_reach = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (i > can_reach) return false;
            can_reach = max(can_reach, i + nums[i]);
        }
        return true;
    }
~~~



##### 2、另一种思维,也很不错的一种思维



C++

其实很简单！

想象你是那个在格子上行走的小人，格子里面的数字代表“能量”，你需要“能量”才能继续行走。

每次走到一个格子的时候，你检查现在格子里面的“能量”和你自己拥有的“能量”哪个更大，取更大的“能量”！ 如果你有更多的能量，你就可以走的更远啦！~



执行用时：20 ms, 在所有 C++ 提交中击败了46.23%的用户

内存消耗：12.7 MB, 在所有 C++ 提交中击败了8.70%的用户

~~~c++
    bool canJump(vector<int>& nums) {
	if (nums.size() == 0)
		return true;

	int cur = nums[0], index = 1;
	for (; cur != 0 && index < nums.size(); index++)
	{
		cur--;
		if (cur < nums[index])
			cur = nums[index];
	}
	return index == nums.size();
    }
~~~



##### 3、最快的一种思路

执行用时：20 ms, 在所有 C++ 提交中击败了46.23%的用户

内存消耗：13.1 MB, 在所有 C++ 提交中击败了8.70%的用户





1. 如果所有元素都不为0， 那么一定可以跳到最后；
2. 从后往前遍历，如果遇到nums[i] = 0，就找i前面的元素j，使得nums[j] > i - j。如果找不到，则不可能跳跃到num[i+1]，返回false。

~~~cpp
 bool canJump(vector<int>& nums){
        if(nums.size() == 1)    return true;
        for(int i = nums.size()-2; i != -1; i--){
            if(!nums[i]){
                int j = 0;
                for(j = i-1; j != -1; j--){
                    if(nums[j] > i-j)  break;
                }
                if(j == -1) return false;
            }
        }
        return true;
    }
~~~



##### 二刷：

执行用时：20 ms, 在所有 C++ 提交中击败了46.78%的用户

内存消耗：12.8 MB, 在所有 C++ 提交中击败了8.70%的用户

~~~c++
    bool canJump(vector<int>& nums) {
        if(nums.size()<=1)  return true;
        int canReach=nums[0],index=0;
        for(;index<nums.size();++index){
            canReach--;
            canReach = max(canReach,nums[index]);
            if(canReach==0)  break;
        }

        return index==nums.size() || (index==nums.size()-1 && canReach==0);//还有一种可能就是到达最后一步而刚好canReach=0，这样直接break了，所以此时index = size-1，而这种情况也是符合的，或者改写为下面的这种形式

    }
~~~



~~~cpp
    bool canJump(vector<int>& nums) {
        if(nums.size()<=1)  return true;
        int canReach=nums[0],index=0;
        for(;canReach!=0 && index<nums.size();++index){//将判断提前，这样一定会走到index++这一步的
            canReach--;
            canReach = max(canReach,nums[index]);
        }
        return index==nums.size();

    }
~~~





#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/) 逻辑有点复杂



给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。

**示例：**

```
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"
```

**说明：**

- 如果 S 中不存这样的子串，则返回空字符串 `""`。
- 如果 S 中存在这样的子串，我们保证它是唯一的答案。



##### 1、滑动窗口来做



滑动窗口，不满足的时候，不断扩大窗口，满足的时候缩小窗口，求最小值



执行用时：76 ms, 在所有 C++ 提交中击败了41.62%的用户

内存消耗：7.8 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    string minWindow(string s, string t) {
    unordered_map<char, int> needs,windows;
	int minLen = INT_MAX,start = 0;
	for (int i = 0; i < t.size(); ++i){
		needs[t[i]]++;
	}


	int match = 0, right = 0, left = 0;
	while (right < s.size()){
		if (needs.count(s[right])>0){
			windows[s[right]]++;
			if (windows[s[right]] == needs[s[right]])
				match++;
		}

		right++;
		while (match == needs.size()){
			if (right - left < minLen)
			{
				minLen = right - left;
				start = left;
			}
			if (needs.count(s[left])>0)
			{
				windows[s[left]]--;
				if (windows[s[left]] < needs[s[left]])
				{
					match--;
				}
			}
			left++;
		}

	}
	return minLen == INT_MAX ? "" : s.substr(start, minLen);
        
    }
~~~



##### 2、滑动窗口第二种做法，会更快

执行用时：20 ms, 在所有 C++ 提交中击败了88.94%的用户

内存消耗：7.7 MB, 在所有 C++ 提交中击败了100.00%的用户



用哈希表完成，由于匹配数组t可能存在重复值，所以map数值需要是int。
总体算法模拟音乐音量上下浮动，t 的元素个数就是音量高度，t 以外的其他元素都为 0，
遍历 s 的过程中，遇到一个音则将其减少一个音量.（* t 数组以外的音量不可能大于 0）
搜索过程中，指定音量下降计数 cnt 增加，减小到 0 以下不算在内，
当减少总数等于 t 的总数时，所有数就齐了，计算长度。
随后进行回退，如果是 t 以外的音，其增加不改变计数 cnt，直到遇到 t 中的音，
且该值在map中大于0时（区间中 t 的某一个音大于其原始的数量，它map的值可能会小于0），
回退停止，继续向前搜索，重复 步骤 2。



~~~cpp
	unordered_map<char, int> hash_map;
	for (auto &c : t) hash_map[c]++;
	int left = 0, cnt = 0, maxlen = s.size() + 1, start = left;
	for (int i = 0; i < s.size(); ++i) {

		if (--hash_map[s[i]] >= 0) //只有在t中出现的元素，--的才会大于等于0，计算匹配的个数
			++cnt;
		while (cnt == t.size()) {
			if (maxlen > i - left + 1) {
				maxlen = i - left + 1;
				start = left;
			}
			if (++hash_map[s[left]] > 0) //因为 left一定是小于 i的 ，换句话说 left经过的字符，
				//至少都被 -- 过一次，也就是会至少等于-1，++之后是0
				cnt--;
			left++;
		}
	}
	return maxlen == s.size() + 1 ? "" : s.substr(start, maxlen);
~~~

#### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)  好题



给定一个二维网格和一个单词，找出该单词是否存在于网格中。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

**示例:**

```
board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

给定 word = "ABCCED", 返回 true
给定 word = "SEE", 返回 true
给定 word = "ABCB", 返回 false
```

 

**提示：**

- `board` 和 `word` 中只包含大写和小写英文字母。
- `1 <= board.length <= 200`
- `1 <= board[i].length <= 200`
- `1 <= word.length <= 10^3`





##### 1、标准回溯

执行用时：200 ms, 在所有 C++ 提交中击败了31.78%的用户

内存消耗：14.7 MB, 在所有 C++ 提交中击败了21.43%的用户

~~~cpp
bool existCore(vector<vector<char>>& board, string& word, map <pair<int, int>, bool > &visited, int row, int col, int begin) {//当前所在元素行 列 以及word中的位序
	if (begin >= word.size() ) return true;
	if (row < 0 || row >= board.size() || col < 0 || col >= board[0].size() || visited[make_pair(row, col)] ||word[begin] != board[row][col] ) return false;
    
	visited[make_pair(row, col)]=true;
	if (existCore(board, word, visited, row - 1, col, begin + 1) ||
		existCore(board, word, visited, row + 1, col, begin + 1) ||
		existCore(board, word, visited, row, col - 1, begin + 1) ||
		existCore(board, word, visited, row, col + 1, begin + 1)
		)
		return true;
	visited[make_pair(row, col)] = false;
	return false;

}
bool exist(vector<vector<char>>& board, string word) {
	int row = board.size(), col = board[0].size();
	map < pair<int, int>, bool > visited;

	for (int i = 0; i < row; ++i) {
		for (int j = 0; j < col; ++j) {
			if (existCore(board, word, visited, i, j, 0))
				return true;
		}
	}

	return false;

}
~~~



##### 2、使用数组降低空间复杂度

执行用时：28 ms, 在所有 C++ 提交中击败了79.74%的用户

内存消耗：8.7 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
bool existCore(vector<vector<char>>& board, string& word, vector<vector<bool>>& visited, int row, int col, int begin) {//当前所在元素行 列 以及word中的位序
	if (begin >= word.size()) return true;
	if (row < 0 || row >= board.size() || col < 0 || col >= board[0].size() || visited[row][col] || word[begin] != board[row][col]) return false;

	visited[row][col] = true;
	if (existCore(board, word, visited, row - 1, col, begin + 1) ||
		existCore(board, word, visited, row + 1, col, begin + 1) ||
		existCore(board, word, visited, row, col - 1, begin + 1) ||
		existCore(board, word, visited, row, col + 1, begin + 1)
		)
		return true;
	visited[row][col] = false;
	return false;

}
bool exist(vector<vector<char>>& board, string word) {
	int row = board.size(), col = board[0].size();
	vector<vector<bool>> visited(row, vector<bool > (col, false));
	for (int i = 0; i < row; ++i) {
		for (int j = 0; j < col; ++j) {
			if (existCore(board, word, visited, i, j, 0))
				return true;
		}
	}
	return false;
}
~~~

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

难度困难780收藏分享切换为英文关注反馈

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 `[2,1,5,6,2,3]`。

 

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 `10` 个单位。

 

**示例:**

```
输入: [2,1,5,6,2,3]
输出: 10
```

##### 1、这种做法真的超级好，要善于利用以前的结果

###### 2.1原生版暴力法超时

```cpp
 int largestRectangleArea(vector<int>& heights) {
	int len = heights.size();
	if (len == 0) return 0;
	if (len == 1) return heights[0];
	int maxArea = -1;
	vector<int> left(len, 0), right(len, 0);//每个节点左右两边能到达不小于自己高度的最大距离
	for (int i = 0; i < len; ++i) {

		int bound = i;
		while (bound - 1 >= 0 && heights[bound - 1] >= heights[i]) bound--;
		left[i] = bound;

		bound = i;
		while (bound + 1 < len && heights[bound + 1] >= heights[i]) bound++;
		right[i] = bound;
	}

	for (int i = 0; i < len; ++i) {
		maxArea = max(maxArea, (right[i] - left[i] + 1) * heights[i]);
		//cout << (right[i] - left[i] + 1) * heights[i]<<" "<<maxArea << endl;
	}
	return maxArea;
    }
```



2.2改良版

执行用时：4 ms, 在所有 C++ 提交中击败了99.99%的用户

内存消耗：8.1 MB, 在所有 C++ 提交中击败了100.00%的用户

```cpp
int largestRectangleArea(vector<int>& heights) {
	int len = heights.size();
	if (len == 0) return 0;
	if (len == 1) return heights[0];
	int maxArea = -1;
	vector<int> left(len, 0), right(len, 0);//每个节点左右两边能到达不小于自己高度的最大距离
	for (int i = 0; i < len; ++i) {

		int bound = i;
		while (bound > 0 && heights[bound - 1] >= heights[i]) bound=left[bound-1];//，如果说bound -1 的值已经很小了，直接用就行，就不用再自己慢慢遍历了，左边最小就是0了，右边最大也就是len-1
		//要善于利用已经得到的结果
		left[i] = bound;
	}

	for (int i = len-1; i >=0 ; --i) {
		int bound = i;
		while (bound < len - 1 && heights[bound + 1] >= heights[i]) bound = right[bound + 1];
		right[i] = bound;
	}
	for (int i = 0; i < len; ++i) {
		maxArea = max(maxArea, (right[i] - left[i] + 1) * heights[i]);
	}
	return maxArea;
}
```







#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)



给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

**示例:**

```
输入:
[
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出: 6
```



##### 1、是84题的进阶版

执行用时：20 ms, 在所有 C++ 提交中击败了97.63%的用户

内存消耗：9.5 MB, 在所有 C++ 提交中击败了100.00%的用户

```cpp
int largestRectangleArea(vector<int>& heights) {
	int len = heights.size();
	if (len == 0) return 0;
	if (len == 1) return heights[0];
	int maxArea = -1;
	vector<int> left(len, 0), right(len, 0);//每个节点左右两边能到达不小于自己高度的最大距离
	for (int i = 0; i < len; ++i) {
		int bound = i;
		while (bound > 0 && heights[bound - 1] >= heights[i]) bound=left[bound-1];//，如果说bound -1 的值已经很小了，直接用就行，就不用再自己慢慢遍历了，左边最小就是0了，右边最大也就是len-1
		//要善于利用已经得到的结果
		left[i] = bound;
	}
	for (int i = len-1; i >=0 ; --i) {
		int bound = i;
		while (bound < len - 1 && heights[bound + 1] >= heights[i]) bound = right[bound + 1];
		right[i] = bound;
	}
	for (int i = 0; i < len; ++i) {
		maxArea = max(maxArea, (right[i] - left[i] + 1) * heights[i]);
	}
	return maxArea;
}

public:
    int maximalRectangle(vector<vector<char>>& matrix) {
        if ( matrix.size()==0 || matrix[0].size()==0 ) return 0;
        int row = matrix.size(), col = matrix[0].size();
        int maxArea = -1;
        vector<int> heights(col,0);//这里是列，而不是行
        for(int i=0; i<row; ++i){
            for(int j=0;j<col;++j){
                if(matrix[i][j]=='1') 
                    heights[j]=heights[j]+1;                
                else
                    heights[j]=0;//这里也是异曲同工之妙，如果遇到0，则这条列上的值就是0了
            }
            maxArea = max(maxArea,largestRectangleArea(heights));
            // cout<<i<<" "<<maxArea<<endl;
        }
        return maxArea;
    }
```





#### [93. 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/) 这回溯太难了



给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

**有效的 IP 地址** 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 `0`），整数之间用 `'.' `分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 **有效的** IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 **无效的** IP 地址。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

**示例 2：**

```
输入：s = "0000"
输出：["0.0.0.0"]
```

**示例 3：**

```
输入：s = "1111"
输出：["1.1.1.1"]
```

**示例 4：**

```
输入：s = "010010"
输出：["0.10.0.10","0.100.1.0"]
```

**示例 5：**

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

 

**提示：**

- `0 <= s.length <= 3000`
- `s` 仅由数字组成



##### 1、看的解答

执行用时：4 ms, 在所有 C++ 提交中击败了73.66%的用户

内存消耗：6.6 MB, 在所有 C++ 提交中击败了93.26%的用户

~~~cpp
bool vaildNum(int left, int right, string& s) {
	int sum = 0;
	if (left != right && s[left] == '0') return false;
	for (int i = left; i <= right; ++i) {		
		sum = sum * 10 + s[i] - '0';
		if (sum > 255) return false;

	}
	return true;
}


void dfs(vector<string>& result, int len, int pointNum, int lastPointIndex, string& cur, string& s) {
	//pointNum . 的个数   lastPointIndex 上一个 . 的位置
	if (pointNum == 3) {// 已经三个点了
		if (vaildNum(lastPointIndex + 1, len - 1, s)) {
			result.push_back(cur);
		}
		return;

	}

	for (int i = lastPointIndex + 1; i < len - 1; ++i) {
		if (vaildNum(lastPointIndex + 1, i, s)) {
			cur.insert(cur.begin() + i + pointNum + 1, '.');
			dfs(result,len, pointNum + 1, i, cur, s);
			cur.erase(pointNum + i + 1, 1);
		}
	}

}


vector<string> restoreIpAddresses(string s) {
	int len = s.size();
	string cur = s;
	vector<string> result;
	dfs(result, len, 0, -1, cur, s);
	return result;

}
~~~



解释：

 对于这道题来说首先把问题转换为在字符串中加.号,保证.号间字符串表示的数小于等于255。回溯条件就是当前加了几个.号和上一个.号的位置。 

~~~cpp
class Solution {
public:
    vector<string> res;
    vector<string> restoreIpAddresses(string s) {
        int n = s.size();
        string cur = s;
        helper(n,0,-1,cur,s);
        return res;
    }
    void helper(int n,int pointnum,int lastpoint,string& cur,string& s) {
        //pointnum记录目前加了几个点了，lastpoint记录上一个点加的位置
        if (pointnum == 3) {
        //如果已经加了三个点了，并且最后一个点的右边表示的数小于255，则是正确IP地址
            if (valid(lastpoint + 1,n-1,s)){
                res.push_back(cur);
            }
            return;
        }
        //从上一个.号的下一个位置开始查找
        for (int i = lastpoint + 1;i < n - 1;i++) {
            //如果字符串s从上一个.号到i位置表示的数小于等于255，则符合条件
            if (valid(lastpoint + 1,i,s)){
                //正常回溯法，注意这里要+pointnum，因为已经加入的.号也会占位
                cur.insert(cur.begin() + i + pointnum + 1,'.');
                helper(n,pointnum + 1,i,cur,s);
                cur.erase(pointnum + i + 1,1);
            }
        }
        return;
    }
    bool valid(int left,int right,string& s) {
        int sum = 0;
        for (int i = left ;i <= right; i++) {
            //处理0开头问题
            if (left != right and s[left] == '0' ) return false;
            //计算字符串s中left到right位表示的数的大小
            sum = sum *10 + (s[i] - '0');
            if (sum > 255) return false;
        }
        return true;
    }
};

~~~







#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)  不会，没思路



给定一个整数 *n*，求以 1 ... *n* 为节点组成的二叉搜索树有多少种？

**示例:**

```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```



##### 1、找规律，树的题目一般都是递归或者找规律

假设n个节点存在二叉排序树的个数是G(n)，令f(i)为以i为根的二叉搜索树的个数

即有:G(n) = f(1) + f(2) + f(3) + f(4) + ... + f(n)

n为根节点，当i为根节点时，其左子树节点个数为[1,2,3,...,i-1]，右子树节点个数为[i+1,i+2,...n]，所以当i为根节点时，其左子树节点个数为i-1个，右子树节点为n-i，即f(i) = G(i-1)*G(n-i),

上面两式可得:G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)

执行用时：0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗：6 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
   int numTrees(int n) {
        if(n <= 0) return 0;
        vector<int> res(n+1,0);
        res[0] = 1;
        res[1] = 1;
        for( int i = 2 ; i <= n; ++i){

            for( int j = 1 ;j <= i; ++j )
                res[i] += res[j-1] * res[i-j];

        }
        return res[n];
    }
~~~



#### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) 牛客上也有

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 `[1,2,2,3,4,4,3]` 是对称的。

```
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 `[1,2,2,null,3,null,3]` 则不是镜像对称的:

```
    1
   / \
  2   2
   \   \
   3    3
```

 

**进阶：**

你可以运用递归和迭代两种方法解决这个问题吗？



##### 1、递归法 好做一些

执行用时：16 ms, 在所有 C++ 提交中击败了13.66%的用户

内存消耗：12.6 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
bool isEqual(TreeNode* node1, TreeNode* node2) {
	if (node1 == nullptr && node2 == nullptr) return true;
	if (node1 == nullptr || node2 == nullptr) return false;//能走到这一步就说明左右不可能同时为空了
	//所以左右若是有一个为空，则返回false
	if(node1->val == node2->val)
		return isEqual(node1->left, node2->right) && isEqual(node1->right, node2->left);
	else
		return	false;
}
bool isSymmetric(TreeNode* root) {//递归法
	if (root == nullptr) return false;//注意这里是返回True的
	return isEqual(root->left, root->right);

}
~~~





##### 2、迭代法  要快上不少

执行用时：4 ms, 在所有 C++ 提交中击败了87.50%的用户

内存消耗：12.9 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~C++
bool isSymmetric(TreeNode* root) {//迭代法
	if (root == nullptr) return true;
    if (root->left == nullptr && root->right == nullptr) return true;//只有一个节点 [1]
	if (root->left == nullptr || root->right == nullptr) return false;
	queue<TreeNode*> q;
	q.push(root->left);
	q.push(root->right);
	TreeNode* node1 = NULL,*node2=NULL;
	while (!q.empty()) {
		node1 = q.front();
		q.pop();
		node2 = q.front();
		q.pop();
		if (node1 == nullptr && node2 == nullptr) continue;
		if (node1 == nullptr || node2 == nullptr || node1->val != node2->val) return false;
		q.push(node1->left);
		q.push(node2->right);
		q.push(node1->right);
		q.push(node2->left);

	}
	return true;

}
~~~



#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)



给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

- 节点的左子树只包含**小于**当前节点的数。
- 节点的右子树只包含**大于**当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1:**

```
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

##### 1、可以借助迭代版中序遍历来做，要记得设置第一次的情况

执行用时：16 ms, 在所有 C++ 提交中击败了69.40%的用户

内存消耗：18.4 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp

    bool isValidBST(TreeNode* root) {
        
        if( root==nullptr ) return true;
        stack<TreeNode*> q;
        TreeNode *node = NULL;
        int lastNum = INT_MIN;
        bool isFirst = true;
        while( !q.empty() || root != nullptr){
            if( root!=nullptr ){
                q.push( root );
                root = root->left;
            }
            else{
                node = q.top();
                q.pop();
                
                 if(isFirst){
                     lastNum = node->val;
                     isFirst = false;
                     root = node->right;
                    continue;
                 } 
                
                if( node->val <= lastNum) return false;
                else{
                    lastNum = node->val;
                }
                root = node->right;
            }
        }

        return true;
    }
~~~



有个测试例子就是 [INT_MIN]



##### 2、递归版中序遍历来做，很妙的一种做法，特别妙，减少很多空间

执行用时：12 ms, 在所有 C++ 提交中击败了92.59%的用户

内存消耗：18.1 MB, 在所有 C++ 提交中击败了100.00%的用户



~~~cpp
class Solution {
public:

    TreeNode*last = NULL;//点睛之笔
    bool isValidBST(TreeNode* root) {
        
        if( root==nullptr ) return true;
        if( !isValidBST( root->left) ) return false;

        if(last != nullptr && last->val >= root->val) return false;
        last = root;

        if( !isValidBST( root->right) ) return false;
        return true;
    }
};
~~~







#### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)



给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

**示例：**
二叉树：`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [9,20],
  [15,7]
]
```

##### 1、常规做法 + 借助队列，这其实是BFS

执行用时：4 ms, 在所有 C++ 提交中击败了88.76%的用户

内存消耗：11.6 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
   vector<vector<int>> levelOrder(TreeNode* root) {
        if(root==nullptr) return vector<vector<int>>();
        queue<TreeNode*> q;
        q.push(root);
        vector<vector<int>> result;
        TreeNode * node=NULL;
        while(!q.empty()){

            int size = q.size();
            vector<int> res;
            while(size--){
                node = q.front();
                q.pop();
                res.push_back(node->val);
                if(node->left) q.push(node->left);
                 if(node->right) q.push(node->right);

            }
            result.emplace_back(std::move(res));
        }
        return result;
    }
~~~





##### 2、DFS

执行用时：4 ms, 在所有 C++ 提交中击败了88.76%的用户

内存消耗：12.7 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
void levelOrderCore(TreeNode* root, vector<vector<int>>& result, int level) {
	if (root == nullptr) return;
    if (level >= result.size())
        result.push_back(vector<int>());//这一步很关键，超级关键
	result[level].push_back(root->val);
	levelOrderCore(root->left, result, level + 1);
	levelOrderCore(root->right, result, level + 1);

}

vector<vector<int>> levelOrder(TreeNode* root) {
	if (root == nullptr) return vector<vector<int>>();
	vector<vector<int>> result;
	levelOrderCore(root, result, 0);
	return result;
}
~~~



#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

难度中等404收藏分享切换为英文关注反馈

给定一个二叉树，[原地](https://baike.baidu.com/item/原地算法/8010757)将它展开为一个单链表。

 

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```

将其展开为：

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```



##### 1、递归做法

执行用时：12 ms, 在所有 C++ 提交中击败了37.11%的用户

内存消耗：11.9 MB, 在所有 C++ 提交中击败了6.67%的用户

~~~cpp
    void flatten(TreeNode* root) {
        if(root==nullptr) return;
        flatten(root->left);
        flatten(root->right);

        TreeNode* temp = root->right;
        root->right = root->left;
        root->left = NULL;
        while(root->right){
            root = root->right;
        }
        root->right = temp;
        
    }
~~~





##### 2、迭代写法

执行用时：12 ms, 在所有 C++ 提交中击败了37.11%的用户

内存消耗：12.1 MB, 在所有 C++ 提交中击败了6.67%的用户

~~~cpp
    void flatten(TreeNode* root) {
        while (root) {
        auto left = root->left;
        if (left) {
            auto last = left;
            while (last->right) last = last->right;
            last->right = root->right;
            root->right = left;
            root->left = nullptr;
        }
        root = root->right;
    }
~~~



#### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)  牛客上的重建二叉树



根据一棵树的前序遍历与中序遍历构造二叉树。

**注意:**
你可以假设树中没有重复的元素。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

##### 1、依然不会，看的一种解释

执行用时：36 ms, 在所有 C++ 提交中击败了59.73%的用户

内存消耗：17.4 MB, 在所有 C++ 提交中击败了42.42%的用户

~~~cpp
TreeNode* buildTree(vector<int>& preorder, int lo1, int hi1, vector<int>& inorder, int lo2, int hi2) {
// preorder: [root, [left], [right]]
// inorder:  [[left], root, [right]]
	if (lo1 > hi1 || lo2 > hi2) return nullptr;
	int rootVal = preorder[lo1];
	int mid = lo2;
	// 在 inorder 中查找 root 位置
	for (int i = lo2; i <= hi2; ++i) {
		if (inorder[i] == rootVal) {
			mid = i;
			break;
		}
	}

	TreeNode* s = new TreeNode(rootVal);
	// 下面的数组表示分割长度
	// preorder:[root, mid-lo2, hi2-mid]
	// inorder: [mid-lo2, mid, hi2-mid]
	s->left = buildTree(preorder, lo1 + 1, lo1 + mid - lo2, inorder, lo2, mid - 1);
	s->right = buildTree(preorder, lo1 + mid - lo2 + 1, hi1, inorder, mid + 1, hi2);
	return s;
}

TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {

	return buildTree(preorder, 0, preorder.size() - 1, inor, inorder.size() - 1);
}
~~~



##### 二刷：1、递归

执行用时：16 ms, 在所有 C++ 提交中击败了96.91%的用户

内存消耗：17.9 MB, 在所有 C++ 提交中击败了42.42%的用户

~~~cpp
TreeNode* buildTreeCore(vector<int>& preorder, int low1, int high1, vector<int>& inorder, int low2, int high2) {
	if (low1 > high1 || low2 > high2) return nullptr;
	int rootVal = preorder[low1];
	int index = low2;
	for (int i = low2; i <= high2; ++i) {
		if (inorder[i] == rootVal)
		{
			index = i;
			break;
		}
	}
	TreeNode* root = new TreeNode(rootVal);
	root->left = buildTreeCore(preorder,low1+1,low1 + index - low2,inorder,low2,index-1);
	root->right = buildTreeCore(preorder,low1 + index - low2 +1,high1, inorder,index+1,high2);
    return root;
}

TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {

	return buildTreeCore(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1);
}
~~~



##### 二刷：2、借助哈希表加速

执行用时：24 ms, 在所有 C++ 提交中击败了81.22%的用户

内存消耗：17.9 MB, 在所有 C++ 提交中击败了42.42%的用户

进行验证时，可以带数进去试试

~~~cpp
TreeNode* buildTreeCore(vector<int>& preorder, unordered_map<int, int> &unmp,int root, int low2, int high2) {
	if (low2 > high2) return nullptr;
	int rootVal = preorder[root],index = unmp[preorder[root]];

	TreeNode* node = new TreeNode(rootVal);

	node->left = buildTreeCore(preorder,unmp,root+1,low2,index-1);
	node->right = buildTreeCore(preorder, unmp, root + 1 + index - low2, index+1, high2);
	return node;
}

TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
	unordered_map<int, int> unmp;
	for (int i = 0; i < preorder.size(); ++i) {
		unmp.insert({inorder[i],i});
	}

	return buildTreeCore(preorder, unmp, 0,0, inorder.size() - 1);
}
~~~





#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)



给定一个**非空**二叉树，返回其最大路径和。

本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径**至少包含一个**节点，且不一定经过根节点。

**示例 1:**

```
输入: [1,2,3]

       1
      / \
     2   3

输出: 6
```

**示例 2:**

```
输入: [-10,9,20,null,null,15,7]

   -10
   / \
  9  20
    /  \
   15   7

输出: 42
```





##### 1、真的是一道好题，超级好的题目，也是dfs吧

执行用时：48 ms, 在所有 C++ 提交中击败了57.30%的用户

内存消耗：28.6 MB, 在所有 C++ 提交中击败了7.69%的用户

~~~cpp
int maxPathSumCore(TreeNode* root, int& result) {

	if (root == nullptr) return  0;
	int left = maxPathSumCore(root->left, result);
	int right = maxPathSumCore(root->right, result);
	int curValue = root->val, leftValue = root->val + left, rightValue = root->val + right, totalValue = root->val + left + right;
	
	//以此节点为根节点的最大值
	int maxValue = max({ curValue,leftValue,rightValue,totalValue });
	//当前遍历树的最大值，进行比较，保存最大值
	result = max(maxValue, result);

	//将当前节点作为一个子节点返回，则需要去掉左右+自己这一种情况，因为不可能走完 左中右 这种情况
	return max({ curValue,leftValue,rightValue });// 这个函数的定义就是返回以root为根节点的二叉树的左右子树中和最大的那一条路径，
	//如果返回left + right + root->val的话函数定义就变了，变成了返回以root为根节点的二叉树的最大路径和了

}
int maxPathSum(TreeNode* root) {

	int result = root->val;
	maxPathSumCore(root, result);
	return result;
}
~~~





#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)



给定一个未排序的整数数组，找出最长连续序列的长度。

要求算法的时间复杂度为 *O(n)*。

**示例:**

```
输入: [100, 4, 200, 1, 3, 2]
输出: 4
```



##### 1、优先队列来做，默认小顶堆 也就是 priority_queue<int,vector<int>,less<int>> 这样的，会将元素从大到小输出



执行用时：36 ms, 在所有 C++ 提交中击败了16.75%的用户

内存消耗：10.1 MB, 在所有 C++ 提交中击败了33.33%的用户



~~~cpp
    int longestConsecutive(vector<int>& nums) {
        if( nums.size() <= 1 )  return nums.size();
        priority_queue<int> q;

        for( auto a:nums )
            q.push(a);
        int count = 1, maxLen = 1;
        int last = q.top();
        q.pop();
        while(!q.empty()){

            if( last - q.top() == 1){
                last = q.top();
                q.pop();
                count++;
            }
            else  if( last - q.top() == 0){ //[ 1 , 2 ,0 ,1] 有可能有重复元素
                q.pop();

            }else{
                maxLen = max( maxLen, count);
                last = q.top();
                count = 1;
                q.pop();

            }
        }
        maxLen = max( maxLen, count );// 可能count直到最后才是最大 的那个元素
        return maxLen;
        
    }
~~~



##### 2、一种unordered_map的做法，效率很高，这种代码真的很优美

执行用时：16 ms, 在所有 C++ 提交中击败了94.64%的用户

内存消耗：11.2 MB, 在所有 C++ 提交中击败了6.67%的用户



使用map记录每个数字是否被遍历过 一次遍历 每次搜索左右相邻数字获取最大长度并把他们标记为已遍历 减少重复遍历带来的性能损失

~~~cpp
    int longestConsecutive(vector<int>& nums) {
        if( nums.size() <= 1 )  return nums.size();
        int  res = 1;
        unordered_map<int,bool>  unmp;
        for( auto&a: nums ){
            unmp.insert( make_pair(a, false) );
        }

        for( auto &a:nums ){
            int left = a, right = a, len = 1 ;
            decltype(unmp.find(a)) iter;
            while( (iter = unmp.find(--left)) != unmp.end() && iter->second != true ) {
                iter->second = true;
                len++;
            }

            while( (iter = unmp.find(++right)) != unmp.end() && iter->second != true ) {
                iter->second = true;
                len++;
            }

            res = max( res, len );
        }
        return res;
        
    }
~~~



#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)



给定一个链表，判断链表中是否有环。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

 

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**示例 2：**

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**示例 3：**

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

 

**进阶：**

你能用 *O(1)*（即，常量）内存解决此问题吗？



##### 1、快慢指针做法

执行用时：12 ms, 在所有 C++ 提交中击败了65.86%的用户

内存消耗：7.5 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    bool hasCycle(ListNode *head) {
        
        if( head == nullptr || head->next == nullptr ) return false;
        ListNode *fast = head, *slow = head;
        while( fast!= nullptr){
            if( fast->next == nullptr || fast->next->next == nullptr )// 这里注意要判断条件
                return false;
            else
                fast = fast->next->next;
            if( slow->next)
                slow = slow->next;
            if( fast == slow ) return true;

        }

        return false;
    }
~~~

##### 2、快慢指针，更稳妥一点的写法

执行用时：8 ms, 在所有 C++ 提交中击败了95.47%的用户

内存消耗：7.5 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    bool hasCycle(ListNode *head) {
        
        if( head == nullptr || head->next == nullptr || head->next->next == nullptr ) return false;
        ListNode *fast = head->next->next, *slow = head->next;
        while( fast != slow){//这里判断条件就不一样了
            if( fast->next == nullptr || fast->next->next == nullptr )
                return false;
            
            fast = fast->next->next;
            slow = slow->next;
        }
        return true;
    }
~~~





#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)



给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。

**说明：**不允许修改给定的链表。

 

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

**示例 2：**

```
输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个节点。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

**示例 3：**

```
输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

 

**进阶：**
你是否可以不用额外空间解决此题？

##### 1、挺多坑的，建议好好看看，特别是前期判断，

执行用时：8 ms, 在所有 C++ 提交中击败了95.91%的用户

内存消耗：7.8 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    ListNode *detectCycle(ListNode *head) {
        if( head == nullptr || head->next == nullptr || head->next->next == nullptr )//这里需要判断三个
            return nullptr;
        ListNode*fast = head->next->next, *slow = head->next;//已经开始走了
        while(slow != fast){
            if( fast->next == nullptr || fast->next->next == nullptr )
                return nullptr;
            fast = fast->next->next;
            slow = slow->next;
        }

        fast = head;
        while( fast != slow){
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
~~~





##### 2、一种神仙做法，我真的是服气

执行用时：8 ms, 在所有 C++ 提交中击败了95.91%的用户

内存消耗：7.6 MB, 在所有 C++ 提交中击败了100.00%的用户



o(n)算法，应该是最快的。 堆的地址从低到高，LeetCode的链表内存是顺序申请的，如果有环，head->next一定小于或等于head，哈哈哈哈哈

~~~cpp
    ListNode *detectCycle(ListNode *head) {
        if( head == nullptr || head->next == nullptr ) return nullptr;
        while(head){
            if(!less<ListNode*>()(head, head->next)) return head->next;

            head = head->next;

        }    
        return nullptr;
    }
~~~









#### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)  超级好题



给定一个单链表 *L*：*L*0→*L*1→…→*L**n*-1→*L*n ，
将其重新排列后变为： *L*0→*L**n*→*L*1→*L**n*-1→*L*2→*L**n*-2→…

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例 1:**

```
给定链表 1->2->3->4, 重新排列为 1->4->2->3.
```

**示例 2:**

```
给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.

```





##### 1、吴师兄题解Java

~~~cpp
public void reorderList(ListNode head) {
    if (head == null || head.next == null) {
        return;
    }

    // 步骤 1: 通过快慢指针找到链表中点
    // 通过调节快慢指针的起始位置，可以保证前半部分的长度大于等于后半部分
    ListNode slow = head, fast = head.next;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

    // 步骤 2: 反转后半部分的链表
    // 在反转之前需要的一个操作是将前后半部分断开
    ListNode second = slow.next;
    slow.next = null;
    second = reverseList(second);

    // 步骤 3: 合并前半部分链表以及反转后的后半部分链表
    mergeList(head, second);
}

private ListNode reverseList(ListNode head) {
    ListNode prev = null, tmp = null, pointer = head;
    while (pointer != null) {
        tmp = pointer.next;
        pointer.next = prev;
        prev = pointer;
        pointer = tmp;
    }

    return prev;
}

private void mergeList(ListNode first, ListNode second) {
    ListNode dummy = new ListNode(0);
    ListNode pointer = dummy;

    while (first != null && second != null) {
        pointer.next = first;
        first = first.next;
        pointer.next.next = second;
        second = second.next;
        pointer = pointer.next.next;
    }

    // 因为我们之前找中点的时候保证了前半部分的长度不小于后半部分的长度
    // 因此交叉后，多出来的部分只可能是前半部分，判断前半部分即可
    if (first != null) {
        pointer.next = first;
    }
}
~~~



##### 2、CPP版本

~~~cpp
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<unordered_map>

using namespace std;

struct ListNode {
	int val;
	ListNode * next;
	ListNode(int _val):val(_val),next(nullptr){}
};


ListNode* reverseList(ListNode* head) {
	ListNode* prev = nullptr, * tmp = nullptr, * pointer = head;
	while (pointer != nullptr) {
		tmp = pointer->next;
		pointer->next = prev;
		prev = pointer;
		pointer = tmp;
	}

	return prev;
}

void mergeList(ListNode* first, ListNode* second) {
	ListNode* dummy = new ListNode(0);
	ListNode* pointer = dummy;

	while (first != nullptr && second != nullptr) {
		pointer->next = first;
		first = first->next;
		pointer->next->next = second;
		second = second->next;
		pointer = pointer->next->next;
	}

	// 因为我们之前找中点的时候保证了前半部分的长度不小于后半部分的长度
	// 因此交叉后，多出来的部分只可能是前半部分，判断前半部分即可
	if (first != nullptr) {
		pointer->next = first;
	}
}

ListNode* reorderList(ListNode *head) {
	if (head == nullptr || head->next == nullptr) {
		return head;
	}

	// 步骤 1: 通过快慢指针找到链表中点
	// 通过调节快慢指针的起始位置，可以保证前半部分的长度大于等于后半部分
	ListNode* slow = head, *fast = head->next;
	while (fast != nullptr && fast->next != nullptr) {
		slow = slow->next;
		fast = fast->next->next;
	}

	// 步骤 2: 反转后半部分的链表
	// 在反转之前需要的一个操作是将前后半部分断开
	ListNode* second = slow->next;
	slow->next = nullptr;
	second = reverseList(second);

	// 步骤 3: 合并前半部分链表以及反转后的后半部分链表
	mergeList(head, second);
	return head;
}







int  main() {
	ListNode* head = new ListNode(1);
	ListNode* node1 = new ListNode(2);
	ListNode* node2 = new ListNode(3);
	ListNode* node3 = new ListNode(4);
	ListNode* node4 = new ListNode(5);

	head->next = node1;
	node1->next = node2;
	node2->next = node3;
	node3->next = node4;
	node4->next = nullptr;


	head = reorderList(head);
	while (head != nullptr) {
		cout << head->val << endl;
		head = head->next;
	}

	return 0;
}
~~~





##### 3、自己写一遍cpp



执行用时：36 ms, 在所有 C++ 提交中击败了99.54%的用户

内存消耗：14.3 MB, 在所有 C++ 提交中击败了38.46%的用户

~~~cpp

#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<unordered_map>

using namespace std;

struct ListNode {
	int val;
	ListNode * next;
	ListNode(int _val):val(_val),next(nullptr){}
};

ListNode* myReverseList(ListNode*head) {


	if (head == nullptr || head->next == nullptr) return head;
	ListNode dumyhead(0);
	ListNode* pre = &dumyhead;
	pre->next = head;
	ListNode* cur = head->next;
	head->next = nullptr;
	ListNode* node = new ListNode(-1);
	while (cur != nullptr) {
		node = cur;
		cur = cur->next;
		node->next = pre->next;
		pre->next = node;

	}

	return dumyhead.next;

}

ListNode* myMerge(ListNode* p1, ListNode* p2) {
	if (p1 == nullptr) return p2;
	if (p2 == nullptr) return p1;

	ListNode dumyhead(0);
	ListNode* pre = &dumyhead;
	while (p1 != nullptr && p2 != nullptr) {
		pre->next = p1;
		p1 = p1->next;
		pre = pre->next;
		pre->next = p2;
		p2 = p2->next;
		pre = pre->next;
	}
	if (p1 != nullptr) pre->next = p1;
	return dumyhead.next;

}

ListNode* myReverOrderList(ListNode *head) {
	if (head == nullptr || head->next == nullptr) return head;
	ListNode* slow = head, * fast = head->next;
	while (fast != nullptr && fast->next != nullptr) {
		slow = slow->next;

		fast = fast->next->next;
	}

	ListNode* second = slow->next;
	slow->next = nullptr;
	second = myReverseList(second);
	

	head = myMerge(head, second);
	return head;


}

int  main() {
	ListNode* head = new ListNode(1);
	ListNode* node1 = new ListNode(2);
	ListNode* node2 = new ListNode(3);
	ListNode* node3 = new ListNode(4);
	ListNode* node4 = new ListNode(5);
	ListNode* node5 = new ListNode(6);

	head->next = node1;
	node1->next = node2;
	node2->next = node3;
	node3->next = node4;
	node4->next = node5;
	node5->next = nullptr;


	head = myReverOrderList(head);
	while (head != nullptr) {
		cout << head->val << endl;
		head = head->next;
	}

	return 0;
}
~~~





#### [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)  好题



运用你所掌握的数据结构，设计和实现一个  [LRU (最近最少使用) 缓存机制](https://baike.baidu.com/item/LRU)。它应该支持以下操作： 获取数据 `get` 和 写入数据 `put` 。

获取数据 `get(key)` - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。
写入数据 `put(key, value)` - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

 

**进阶:**

你是否可以在 **O(1)** 时间复杂度内完成这两种操作？

 

**示例:**

```
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // 返回  1
cache.put(3, 3);    // 该操作会使得关键字 2 作废
cache.get(2);       // 返回 -1 (未找到)
cache.put(4, 4);    // 该操作会使得关键字 1 作废
cache.get(1);       // 返回 -1 (未找到)
cache.get(3);       // 返回  3
cache.get(4);       // 返回  4
```





##### 1、双向链表 + hash_map 超级棒 实现 o(1)



执行用时：192 ms, 在所有 C++ 提交中击败了81.99%的用户

内存消耗：37.4 MB, 在所有 C++ 提交中击败了92.86%的用户

~~~cpp
struct DoubleLinkList {
	DoubleLinkList* pre;
	DoubleLinkList* next;
	int key;
	int value;
	DoubleLinkList(int key, int value) : key(key), value(value), pre(NULL), next(NULL) {};
};

class LRUCache {
public:
	// 表头
	DoubleLinkList* head;
	// 表尾
	DoubleLinkList* tail;
	// 缓存，记录key所对应的链表节点
	unordered_map<int, DoubleLinkList*> memory;
	// 容量
	int cacheCapacity = 0;
	LRUCache(int capacity) {
		// 初始化
		cacheCapacity = capacity;
		head = new DoubleLinkList(-1, -1);
		tail = new DoubleLinkList(-1, -1);
		head->next = tail;
		tail->pre = head;
	}

	int get(int key) {
		// 如果缓存中查找到该key, 则需更新该key为最近使用（即放到表尾）
		if (memory.find(key) != memory.end()) {
			DoubleLinkList* node = memory[key];
			// 从链表中移除该节点
			removeNode(node);
			// 将该节点放至表尾
			pushNode(node);
			return node->value;
		}
		return -1;
	}

	void put(int key, int value) {
		// 如果缓存中有当前key
		if (memory.find(key) != memory.end()) {
			DoubleLinkList* node = memory[key];
			// 从链表中移除该节点
			removeNode(node);
			// 将该节点放至表尾
			pushNode(node);
			// 修改节点对应的值
			node->value = value;
			return;
		}
		// 如果内存已经放满
		if (memory.size() == cacheCapacity) {
			// 获取链表头结点的key
			int topKey = head->next->key;
			// 移除链表中的首个节点，并从memory中移除该key
			removeNode(head->next);
			memory.erase(topKey);
		}
		// 表尾放置新key
		DoubleLinkList* node = new DoubleLinkList(key, value);
		pushNode(node);
		// 存入缓存
		memory[key] = node;
	}
	// 从链表中移除节点
	void removeNode(DoubleLinkList* node) {
		// 将该节点从链表中移除
		node->pre->next = node->next;
		node->next->pre = node->pre;
	}
	// 表尾插入结点，这部分可以画个图看一下就知道了
	void pushNode(DoubleLinkList* node) {
		node->pre = tail->pre;
		tail->pre->next = node;
		node->next = tail;
		tail->pre = node;
	}
};
~~~



##### 二刷：很重要的一个手写算法

~~~cpp
struct ListNode {
	int key;
	int val;
	ListNode* pre;
	ListNode* next;
	ListNode(int _key, int _val) :key(_key), val(_val), pre(nullptr), next(nullptr) {};
};




class LRUCache {
public:
	ListNode* head, *tail;//最新值永远在尾巴
	unordered_map<int, ListNode*> memory;
	int cacheCapacity = 0;
	LRUCache(int capacity) {
		cacheCapacity = capacity;
		head = new ListNode(-1, -1);
		tail = new ListNode(-1, -1);
		head->next = tail;
		tail->pre = head;
	}

	~LRUCache() {
		if (head != nullptr) {
			delete head;
			head = nullptr;
		}
		if (tail != nullptr) {
			delete tail;
			tail = nullptr;
		}
	}
	int get(int key) {
		if (memory.find(key) != memory.end()) {
			ListNode* node = memory[key];
			removeNode(node);
			pushNode(node);
			return node->val;

		}
		return -1;
	}

	void put(int key, int value) {

		// 当前缓存中有key，那就移动到末尾，代表最新一次访问，并且更新值
		if (memory.find(key) != memory.end()) {
			ListNode* node = memory[key];
			removeNode(node);
			pushNode(node);
			node->val = value;
			return ;

		}
		//当前缓冲中没有该值，判断是否已满，如果满，就删除头
		if (memory.size() == cacheCapacity) {
			int topKey = head->next->key;
			removeNode(head->next);
			memory.erase(topKey);
		}
		//添加进新元素
		ListNode* node = new ListNode(key, value);
		pushNode(node);
		memory[key] = node;//并且要更新值

	}

	void removeNode(ListNode* node) {

		node->pre->next = node->next;
		node->next->pre = node->pre;
	}

	void pushNode(ListNode* node) {

		node->pre = tail->pre;
		tail->pre->next = node;
		node->next = tail;
		tail->pre = node;
	}
};
~~~







再次复写

~~~cpp
struct DoubleList {
	int key, val;
	DoubleList* pre, *next;
	DoubleList(int _key,int _val):key(_key),val(_val),pre(nullptr),next(nullptr){}
};

class LRUCache {

public:
	LRUCache(int capa) {
		this->capacity = capa;
		head = new DoubleList(-1, -1);
		tail = new DoubleList(-1, -1);
		head->next = tail;
		tail->pre = head;

	}


	~LRUCache() {
		if (head != nullptr) {
			delete head;
			head = nullptr;
		}
		if (tail != nullptr) {
			delete tail;
			tail = nullptr;
		}

		for (auto& a : memory) {
			if (a.second != nullptr) {
				delete a.second;
				a.second = nullptr;
			}
		}
	}

	void put(int _key, int _val) {
		if (memory.find(_key) != memory.end()) {//当前内存中有该值

			DoubleList* node = memory[_key];
			node->val =  _val;
			removeNode(node);
			insertNode(node);//将其放入链表的尾部
		}
		//当前内存中没有该值
		if (memory.size() == capacity) {
			int topKey = head->next->key;
			memory.erase(topKey);
			removeNode(head->next);
		}

		DoubleList* node = new DoubleList(_key, _val);
		insertNode(node);
		memory[_key] = node;

	}
	int get(int _key) {
		if (memory.find(_key) != memory.end()) {
			DoubleList* node = memory[_key];
			removeNode(node);
			insertNode(node);
			return node->val;
		}
		return -1;

	}
	void insertNode(DoubleList* node) {
		tail->pre->next = node;
		node->pre = tail->pre;
		node->next = tail;
		tail->pre = node;
	}

	void removeNode(DoubleList* node) {
		node->pre->next = node->next;
		node->next->pre = node->pre;

	}


private:
	unordered_map<int, DoubleList*> memory;
	DoubleList* head, *tail;
	int capacity;

};

~~~



#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)  很好的题，这题真的超级棒



在 *O*(*n* log *n*) 时间复杂度和常数级空间复杂度下，对链表进行排序。

**示例 1:**

```
输入: 4->2->1->3
输出: 1->2->3->4
```

**示例 2:**

```
输入: -1->5->3->4->0
输出: -1->0->3->4->5
```



##### 1、普通做法  sort是 N*logN，但是空间是O n了

执行用时：96 ms, 在所有 C++ 提交中击败了29.66%的用户

内存消耗：19.2 MB, 在所有 C++ 提交中击败了12.50%的用户

~~~cpp
    ListNode* sortList(ListNode* head) {
        if(head == nullptr || head->next == nullptr ) return head;//注意条件判断
        multimap<int,ListNode*> mp;//链表中可能含有重复元素，所以要是multimap
        while( head ){
            mp.insert( {head->val, head } );
            head = head->next;

        }
        auto beg = mp.begin();
        head = beg->second;
        ListNode *temp = head;
        while( ++beg != mp.end() ){
            temp->next = beg->second;
            temp = temp->next;
        }
        temp->next = NULL;
        return head;
    }
~~~





##### 2、优化一下，减少一部分空间和时间，但是还是不满足题目的要求的

执行用时：76 ms, 在所有 C++ 提交中击败了65.87%的用户

内存消耗：16 MB, 在所有 C++ 提交中击败了12.50%的用户

~~~cpp
    ListNode* sortList(ListNode* head) {
	if (head == nullptr || head->next == nullptr) return head;//注意条件判断
	vector<int> res;//链表中可能含有重复元素，所以要是multimap
	ListNode* temp = head;
    while (temp) {
		res.push_back(temp->val);
		temp = temp->next;

	}

	sort(res.begin(), res.end());
	head->val = res[0];
	temp = head;
	for (int i = 1; i < res.size(); ++i) {
		temp->next->val = res[i];
		temp = temp->next;
	}
	temp->next = nullptr;
	return head;
    }
~~~



##### 3、前两种做法并不符合要求，要用 自下向顶 + 双路归并来做





执行用时：92 ms, 在所有 C++ 提交中击败了33.67%的用户

内存消耗：15.4 MB, 在所有 C++ 提交中击败了12.50%的用户



~~~cpp
class Solution {
public:

ListNode* sortList(ListNode* head) {
	ListNode dummyHead(0);
	dummyHead.next = head;
	auto p = head;
	int length = 0;
	while (p) {
		++length;//统计出链表长度
		p = p->next;
	}

	for (int size = 1; size < length; size *= 2) {
		ListNode* cur = dummyHead.next;
		ListNode* tail = &dummyHead;

		while (cur != nullptr) {
			ListNode* left = cur;
			ListNode* right = cut(left, size); // left->@->@ right->@->@->@...
			cur = cut(right, size); // left->@->@ right->@->@  cur->@->...

			tail->next = merge(left, right);//  tail  保持连接，一直是当前链表的最后一个元素
			while (tail->next != nullptr) {
				tail = tail->next;
			}
		}
	}
	return dummyHead.next;
}

ListNode* cut(ListNode* head, int n) {//cut(l, n)，可能有些同学没有听说过，它其实就是一种 split 操作，即断链操作。
	//不过我感觉使用 cut 更准确一些，它表示，将链表 l 切掉前 n 个节点，并返回后半部分的链表头。


	ListNode* p = head;
	while (--n && p) {
		p = p->next;
	}

	if (p == nullptr ) return nullptr;

	ListNode* next = p->next;
	p->next = nullptr;//这里是要置空的，将这个链表断开，并且返回后面链表的第一个值
	return next;
}



ListNode* merge(ListNode* l1, ListNode* l2) {//双路归并
	ListNode dummyHead(0);
	ListNode* p = &dummyHead;
	while (l1 && l2) {
		if (l1->val > l2->val) swap(l1, l2);
		p->next = l1;
		l1 = l1->next;
		p = p->next;			
	}
	p->next = l1 ? l1 : l2;
	return dummyHead.next;
}


};
~~~



##### 二刷：需要注意的地方很多

~~~cpp
class Solution {
public:

	ListNode* sortList(ListNode* head) {
		if (head == nullptr || head->next == nullptr) return head;
		ListNode dummyHead(0);//注意这里的写法
		dummyHead.next = head;//注意这里的写法
		ListNode * node =  head;//注意这里的写法

		int length = 0;
		while (node != nullptr) {
			node = node->next;
			length++;
		}

		for (int seg = 1; seg < length; seg *= 2) {
			ListNode *cur = dummyHead.next;//注意这里的写法
			ListNode* tail = &dummyHead;//注意这里的写法

			while (cur != nullptr) {
				ListNode* left = cur;
				ListNode* right = cut(left, seg);
				cur = cut(right, seg);

				tail->next = twoMerge(left, right);
				while (tail->next != nullptr)
					tail = tail->next;
			}
		}
		return dummyHead.next;
	}


	ListNode* cut(ListNode* l, int size) {
		ListNode* p = l;//注意这里的写法
		while (--size && p != nullptr ) {
			p = p->next;
		}
		if (p == nullptr) return nullptr;

		ListNode* next = p->next;
		p->next = nullptr;

		return next;
	}


	ListNode* twoMerge(ListNode* l1, ListNode* l2) {
		ListNode dummyHead(0);//注意这里的写法
		ListNode* node = &dummyHead;//注意这里的写法
		while (l1 != nullptr && l2 != nullptr) {

			if (l1->val > l2->val) swap(l1, l2);
			node->next = l1;
			l1 = l1->next;
			node = node->next;
		}

		node->next = (l1 == nullptr ? l2 : l1);//这里注意是 node - >next

		return dummyHead.next;
	}
};
~~~







#### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)



编写一个程序，找到两个单链表相交的起始节点。

如下面的两个链表**：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

 

**示例 1：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

 

**示例 2：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

 

**示例 3：**

[![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

 

**注意：**

- 如果两个链表没有交点，返回 `null`.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。





##### 1、我感觉依然挺难的啊。。呜呜呜，一种常规做法

执行用时：64 ms, 在所有 C++ 提交中击败了40.23%的用户

内存消耗：14.4 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
 ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if( headA == nullptr || headB == nullptr ) return nullptr;
        //1、分别计算长度
        ListNode*A = headA,*B = headB;
        int lenA = 1, lenB = 1;
        while( A->next != nullptr){
            A = A->next;
            lenA++;
        }
        lenA++;

        while( B->next != nullptr){
            B = B->next;
            lenB++;
        }
        lenB++;

        //计算差值，让长的先走差值
        int diff = lenA - lenB;
        A = headA;
        B = headB;
        if( diff>0 ){
            while( diff>0 ){
                A = A->next;
                diff--;
            }

        }else {
                while( diff < 0 ){
                B = B->next;
                diff++;
            }
        }

        //3，两指针同时走
        while( A != B ){
            A = A->next;
            B = B->next;
        }
        return A;


    }
~~~





##### 2、第二种做法，神仙做法，真的神仙做法



执行用时：56 ms, 在所有 C++ 提交中击败了77.19%的用户

内存消耗：14.5 MB, 在所有 C++ 提交中击败了100.00%的用户



~~~cpp
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if( headA == nullptr || headB == nullptr ) return nullptr;
        ListNode*pA = headA,*pB = headB;
        while( pA != pB ) {
            pA = (pA == nullptr ? headB: pA->next);
            pB = (pB == nullptr ? headA: pB->next);
        }
        return pA;
    }
~~~





#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)



给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数**大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1:**

```
输入: [3,2,3]
输出: 3
```

**示例 2:**

```
输入: [2,2,1,1,1,2,2]
输出: 2
```



##### 1、很easy的一种解法

执行用时：28 ms, 在所有 C++ 提交中击败了56.69%的用户

内存消耗：8.9 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
    int majorityElement(vector<int>& nums) {
        unordered_map<int,int> unmp;
        int len = nums.size();
        for( auto n:nums ){
            unmp[n]++;
            if(unmp[n] > len/2 ) return n;
        }
        return 0;
    }
~~~



##### 2、摩尔投票法

执行用时：16 ms, 在所有 C++ 提交中击败了94.06%的用户

内存消耗：8.7 MB, 在所有 C++ 提交中击败了100.00%的用户

[1, 2,    2,   2,     2,       3,      2,    4,     5 ]

2,2 ,2 ,2 ,2    : 5

1,3 4,5  :      4


~~~cpp
 int majorityElement(vector<int>& nums) {
//摩尔投票法,先假设第一个数过半数并设cnt=1；遍历后面的数如果相同则cnt+1，不同则减一，当cnt为0时则更换新的数字为候选数（成立前提：有出现次数大于n/2的数存在）
        int res=0,cnt=0;
        for(int i=0;i<nums.size();i++){
            if(cnt==0) {
                res=nums[i];
                cnt++;
            }
            else{
                if(res == nums[i])
                    cnt++;
                else
                    cnt--;
                //res==nums[i]?cnt++:cnt--;
            }
        }
        return res;
    }
~~~



#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)



给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1:**

```
输入:
[
['1','1','1','1','0'],
['1','1','0','1','0'],
['1','1','0','0','0'],
['0','0','0','0','0']
]
输出: 1
```

**示例 2:**

```
输入:
[
['1','1','0','0','0'],
['1','1','0','0','0'],
['0','0','1','0','0'],
['0','0','0','1','1']
]
输出: 3
解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。
```



##### 1、常规做法，也不算常规的一种做法，曾几何时，我也会这种题了

执行用时：28 ms, 在所有 C++ 提交中击败了13.66%的用户

内存消耗：9.6 MB, 在所有 C++ 提交中击败了100.00%的用户

将与当前岛屿相关的岛屿全部沉下去

~~~cpp
 void numIslandsCore(vector<vector<char>>&grid, int i, int j){
        int row = grid.size(), col =grid[0].size();
        if( i < 0 || i >= row || j < 0 || j >= col || grid[i][j] == '0' ) return;//越界或者当前不为岛屿，则返回
        grid[i][j] = '0';//将当前岛屿沉下去
        numIslandsCore( grid, i + 1, j);
        numIslandsCore( grid, i - 1, j);
        numIslandsCore( grid, i, j + 1 ) ;
        numIslandsCore( grid, i, j - 1 );


    }

    int numIslands(vector<vector<char>>& grid) {

        int count = 0;
        if( grid.size() == 0 || grid[0].size() == 0) return 0;
        int row = grid.size(), col =grid[0].size();
        for( int i = 0; i < row; ++i ){
            for( int j = 0; j < col; ++j){

                if(grid[i][j] == '1') 
                    {
                        numIslandsCore( grid, i, j);
                        count++;
                    }
            }
        }

        return count;

    }
~~~



#### [面试题 16.19. 水域大小](https://leetcode-cn.com/problems/pond-sizes-lcci/)



你有一个用于表示一片土地的整数矩阵`land`，该矩阵中每个点的值代表对应地点的海拔高度。若值为0则表示水域。由垂直、水平或对角连接的水域为池塘。池塘的大小是指相连接的水域的个数。编写一个方法来计算矩阵中所有池塘的大小，返回值需要从小到大排序。

**示例：**

```
输入：
[
  [0,2,1,0],
  [0,1,0,1],
  [1,1,0,1],
  [0,1,0,1]
]
输出： [1,2,4]
```

**提示：**

- `0 < len(land) <= 1000`
- `0 < len(land[i]) <= 1000`



##### 1、标准DFS

执行用时：280 ms, 在所有 C++ 提交中击败了77.99%的用户

内存消耗：31.9 MB, 在所有 C++ 提交中击败了82.86%的用户

~~~cpp
void pondSizesCore(vector<vector<int>>& land, int row, int col,int &area) {
	if (row < 0 || col < 0 || row >= land.size() || col >= land[0].size() || land[row][col] != 0) return;
	area++;
	land[row][col] = 1;

	pondSizesCore(land, row + 1, col, area);
	pondSizesCore(land, row - 1, col, area);
	pondSizesCore(land, row, col + 1, area);
	pondSizesCore(land, row, col - 1, area);
	pondSizesCore(land, row - 1, col - 1, area);
	pondSizesCore(land, row + 1, col - 1, area);
	pondSizesCore(land, row + 1, col + 1, area);
	pondSizesCore(land, row - 1, col + 1, area);

}

vector<int> pondSizes(vector<vector<int>>& land) {
	
	int rows = land.size(), cols = land[0].size();
	vector<int> result;
	for (int i = 0; i < rows; ++i) {
		for (int j = 0; j < cols; ++j) {
			if (land[i][j] == 0)
			{
				int area = 0;
				pondSizesCore(land, i, j, area);
				result.push_back(area);
				
			}

		}
	}

	sort(result.begin(), result.end());
	return result;

}
~~~





#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)  好题，看完没有头绪



你这个学期必须选修 `numCourse` 门课程，记为 `0` 到 `numCourse-1` 。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：`[0,1]`

给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？

 

**示例 1:**

```
输入: 2, [[1,0]] 
输出: true
解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。
```

**示例 2:**

```
输入: 2, [[1,0],[0,1]]
输出: false
解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。
```

 

**提示：**

1. 输入的先决条件是由 **边缘列表** 表示的图形，而不是 邻接矩阵 。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。
2. 你可以假定输入的先决条件中没有重复的边。
3. `1 <= numCourses <= 10^5`



##### 1、是我想得太简单了

~~~cpp
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

    if(prerequisites.size() == 0 || prerequisites[0].size() == 0) return true;//力扣贼喜欢搞这些空测试
	int count = 0;
	vector<pair<int, int>> result;
	for (auto& pre : prerequisites) {
		auto pos = find(result.begin(), result.end(), make_pair(pre[1], pre[0]));
		if ( pos == result.end()) {
			result.push_back(make_pair(pre[0], pre[1]));
			count +=2;
		}
		else {
			result.erase(pos);
			count -=2;
		}
	}

	return count <= numCourses;
    }
~~~





##### 2、原来是图的题，用拓扑排序来做，看大神做法



拓扑排序模板代码。该背还是得背。

 模板： **构建邻接表和入度数组->入度为 0入队->广度遍历**

原理：

- step.1 找所有 indegree （入度）为 0 的顶点，然后删掉它们。如果找不到跳转到 step.2，否则继续 step.1
- step.2 结束

如果拓扑排序无法遍历所有顶点，说明存在环。





第二个解释：

思路1：拓扑排序。构建的邻接表就是我们通常认识的邻接表，每一个结点存放的是后继结点的集合。

该方法的每一步总是输出当前无前趋（即入度为零）的顶点。为避免每次选入度为 $0$ 的顶点时扫描整个存储空间，可设置一个队列暂存所有入度为 $0$ 的顶点。

具体做法如下：

1、在开始排序前，扫描对应的存储空间，将入度为 0 的顶点均入队列。

2、只要队列非空，就从队首取出入度为 0 的顶点，将这个顶点输出到结果集中，并且将这个顶点的所有邻接点的入度减 1，在减 1 以后，发现这个邻接点的入度为 0 ，就继续入队。

最后检查结果集中的顶点个数是否和课程数相同即可。





统计每个课被指向次数，初始被指向次数为0的肯定是安全的（不在环上）。

每被安全课程指向一次，被指次数减一，

如果被指次数减到0，说明该课程全部指向都来自安全课程，则它也是安全的。

依此进行队列循环。





执行用时：40 ms, 在所有 C++ 提交中击败了63.18%的用户

内存消耗：14 MB, 在所有 C++ 提交中击败了25.00%的用户



~~~cpp
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

	map<int, set<int>> adjcent;
	vector<int> indegree(numCourses);
	for (auto& edge : prerequisites) {
		int a = edge[0], b = edge[1];
		adjcent[b].insert(a);//当前课是哪些课的先驱
		++indegree[a];//要学当前课，你需要先学多少门课
	}

	int count = 0;
	queue<int> todo;
	for (int i = 0; i < numCourses; ++i) {
		if (indegree[i] == 0) todo.push(i);//入度为0，则入队列，
		//表示当前课并不需要任何课程就能学，这是个安全课程
	}

	while (!todo.empty()) {
		int v = todo.front();
		todo.pop();
		++count;

		auto& adjs = adjcent[v];//统计还有哪些安全课，
		//因为v是安全的，adjcent[v]表示那些需要先学v才能学的课程
		for (auto adj : adjs) {
			--indegree[adj];//当前v是安全的，那么需要学v才能学的课程也递减一下，
			//直到安全未知，也就是入度为0，那么它也是安全的了
			if (indegree[adj] == 0) todo.push(adj);
		}
	}
	return count == numCourses;
    }

~~~



 实现基本拓扑排序：

 1、找到入度为0的点；

 2、删除该点，相邻点的入度-1；

 3、重复步骤1； 若所有点均被删除，则认为拓扑排序成功。 



##### 3、优化一下时间

~~~cpp
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {

	unordered_map<int, unordered_set<int>> adjcent;//使用无序映射
	vector<int> indegree(numCourses);
	for (auto& edge : prerequisites) {
		int a = edge[0], b = edge[1];
		adjcent[b].insert(a);//当前课是哪些课的先驱
		++indegree[a];//要学当前课，你需要先学多少门课
	}

	int count = 0;
	queue<int> todo;
	for (int i = 0; i < numCourses; ++i) {
		if (indegree[i] == 0) todo.push(i);//入度为0，则入队列，
		//表示当前课并不需要任何课程就能学，这是个安全课程
	}

	while (!todo.empty()) {
		int v = todo.front();
		todo.pop();
		++count;

		auto& adjs = adjcent[v];//统计还有哪些安全课，
		//因为v是安全的，adjcent[v]表示那些需要先学v才能学的课程
		for (auto adj : adjs) {
			--indegree[adj];//当前v是安全的，那么需要学v才能学的课程也递减一下，
			//直到安全未知，也就是入度为0，那么它也是安全的了
			if (indegree[adj] == 0) todo.push(adj);
		}
	}
	return count == numCourses;
    }
~~~





#### [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)  又是一道好题



实现一个 Trie (前缀树)，包含 `insert`, `search`, 和 `startsWith` 这三个操作。

**示例:**

```
Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // 返回 true
trie.search("app");     // 返回 false
trie.startsWith("app"); // 返回 true
trie.insert("app");   
trie.search("app");     // 返回 true
```

**说明:**

- 你可以假设所有的输入都是由小写字母 `a-z` 构成的。
- 保证所有输入均为非空字符串。



##### 1、大神做法，第一次听说前缀树的说法

~~~cpp
class Trie {
public:
	Trie* child[26];
	bool isEnd;
	/** Initialize your data structure here. */
	Trie() {
		this->isEnd = false;
		for (int i = 0; i < 26; ++i) {
			this->child[i] = nullptr;
		}

	}

	~Trie() {
		for (int i = 0; i < 26; ++i) {
			if (this->child[i]) {
				delete child[i];
				child[i] = nullptr;

			}
		}

	}
	/** Inserts a word into the trie. */
	void insert(string word) {
		Trie* node = this;
		for (auto& c : word) {
			if (node->child[c - 'a'] == nullptr)
				node->child[c - 'a'] = new Trie();

			node = node->child[c - 'a'];
		}
		node->isEnd = true;
	}

	/** Returns if the word is in the trie. */
	bool search(string word) {
		Trie* node = this;
		for (auto& c : word) {
			if (node->child[c - 'a'] == nullptr)
				return false;
			node = node->child[c - 'a'];
		}

		return node->isEnd;
	}

	/** Returns if there is any word in the trie that starts with the given prefix. */
	bool startsWith(string prefix) {
		Trie* node = this;
		for (auto& c : prefix) {
			if (node->child[c - 'a'] == nullptr)
				return false;
			node = node->child[c - 'a'];
		}

		return true;
	}
};
~~~



##### 2、智能指针来进行内存管理



~~~cpp

struct TrieNode {
  unique_ptr<TrieNode> childs[26];
  bool isEnd;
  TrieNode(bool _isEnd) : isEnd(_isEnd) {
    for (int i = 0; i < 26; ++i) childs[i] = nullptr;
  }
};

class Trie {
  unique_ptr<TrieNode> root;

 public:
  /** Initialize your data structure here. */
  Trie() : root(new TrieNode(true)) {}

  /** Inserts a word into the trie. */
  void insert(string word) {
    TrieNode* cur = root.get();
    for (int i = 0; i < word.size(); ++i) {
      int idx = word[i] - 'a';
      if (cur->childs[idx] == nullptr) {
        cur->childs[idx].reset(new TrieNode(false));
      }
      cur = cur->childs[idx].get();
    }
    cur->isEnd = true;
  }

  /** Returns if the word is in the trie. */
  bool search(string word) {
    TrieNode* cur = root.get();
    for (int i = 0; i < word.size(); ++i) {
      int idx = word[i] - 'a';
      if (cur->childs[idx] == nullptr) {
        return false;
      } else {
        cur = cur->childs[idx].get();
      }
    }
    return cur->isEnd;
  }

  /** Returns if there is any word in the trie that starts with the given
   * prefix. */
  bool startsWith(string prefix) {
    TrieNode* cur = root.get();
    for (int i = 0; i < prefix.size(); ++i) {
      int idx = prefix[i] - 'a';
      if (cur->childs[idx] != nullptr) {
        cur = cur->childs[idx].get();
      } else {
        return false;
      }
    }
    return true;
  }
};

~~~





##### 第二天二刷复盘：

执行用时：136 ms, 在所有 C++ 提交中击败了36.39%的用户

内存消耗：44.3 MB, 在所有 C++ 提交中击败了54.55%的用户

~~~cpp
class Trie {

	Trie *child[26];
	bool isEnd;
public:
    /** Initialize your data structure here. */
    Trie() {
		this->isEnd = false;
		for(int i = 0; i < 26; ++i){
			this->child[i] = nullptr;
		}
    }

	~Trie(){
		for(int i = 0; i < 26; ++i){
			if(this->child[i]){
				delete this->child[i];
				this->child[i] = nullptr;
			}
		}
 

	}
    
    /** Inserts a word into the trie. */
    void insert(string word) {
		Trie *node = this;
		for(auto c: word){
			if(node->child[c-'a'] == nullptr)
				node->child[c-'a'] = new Trie();
			node = node->child[c-'a'];
		}
		node->isEnd = true;
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {

		Trie *node = this;
		for(auto c: word){
			if(node->child[c-'a'] == nullptr)
				return false;
			node = node->child[c-'a'];
		}
		return node->isEnd;
    }
    
    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
		Trie *node = this;
		for(auto c: prefix){
			if(node->child[c-'a'] == nullptr)
				return false;
			node = node->child[c-'a'];
		}
		return true;
    }
};
~~~







#### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)



翻转一棵二叉树。

**示例：**

输入：

```
     4
   /   \
  2     7
 / \   / \
1   3 6   9
```

输出：

```
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

##### 1、递归做法



执行用时：4 ms, 在所有 C++ 提交中击败了60.31%的用户

内存消耗：9.1 MB, 在所有 C++ 提交中击败了45.95%的用户

~~~cpp
    TreeNode* invertTree(TreeNode* root) {
        if( root == nullptr ) return nullptr;
        std::swap(root->right,root->left);
        invertTree( root->right );
        invertTree( root->left );

        return root;

    }
~~~



###### 1-1利用前序遍历

执行用时：4 ms, 在所有 C++ 提交中击败了60.31%的用户

内存消耗：9.2 MB, 在所有 C++ 提交中击败了5.41%的用户

~~~cpp
    TreeNode* invertTree(TreeNode* root) {
	if (root == nullptr) return nullptr;
	TreeNode* node = root->right;//首先保存右子树
	root->right = invertTree(root->left);
	root->left = invertTree(node);
	return root;

    }
~~~

###### 1-2利用中序遍历来做

执行用时：4 ms, 在所有 C++ 提交中击败了60.31%的用户

内存消耗：9.4 MB, 在所有 C++ 提交中击败了5.41%的用户

~~~cpp
TreeNode* invertTree(TreeNode* root) {
	if (root == nullptr) return nullptr;
	invertTree(root->left);//递归找到左节点
	TreeNode* rightNode = root->right;//首先保存右子树
	root->right = root->left;
	root->left = rightNode;
	//递归找到右节点，因为此时已经交换过了，所以此时右节点是root->left
	invertTree(root->left);
	return root;
}
~~~



##### 2、迭代做法，也就是层次遍历来做

执行用时：4 ms, 在所有 C++ 提交中击败了60.31%的用户

内存消耗：9.5 MB, 在所有 C++ 提交中击败了5.41%的用户

~~~cpp
TreeNode* invertTree(TreeNode* root) {
	if (root == nullptr) return nullptr;
	//层次遍历，直接交换即可
	queue<TreeNode*> q;
	q.push(root);
	while (!q.empty()) {
		TreeNode* node = q.front();
		q.pop();
		TreeNode* rightNode = node->right;
		node->right = node->left;
		node->left = rightNode;
		if (node->right) q.push(node->right);
		if (node->left) q.push(node->left);
	}
	return root;
}
~~~





#### [229. 求众数 II](https://leetcode-cn.com/problems/majority-element-ii/)



给定一个大小为 *n* 的数组，找出其中所有出现超过 `⌊ n/3 ⌋` 次的元素。

**说明:** 要求算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

**示例 1:**

```
输入: [3,2,3]
输出: [3]
```

**示例 2:**

```
输入: [1,1,1,3,3,2,2,2]
输出: [1,2]
```





##### 1、摩尔投票法的运用

###### 1、第一种解释

开始之前
候选人允许任意多，但大多数题解举的例子是三个候选人，如[1,1,2,3,3]，没有回答完整

笔者发现从柱形图角度可以比较好地理解算法的操作，是
@user7612p 的 这个题解的具体化说明

![](https://pic.leetcode-cn.com/e6d7b18b7ba13ce4bcdb26447dce1546b4043ac86f6cba0e1036cf70824c34c6-a99e82f78b9e2189f3e02daea6f55b1d6bfe91eb03599a22002ca879afbabfd7-image.png)

首先明确，A、B指的是出现次数最大的两个，不一定满足n/3，但我们先要找到它们

核心就一句话：

每次都拿走3个不一样的数, 那么最后剩下的, 一定是A, B.

接下来就从柱形图角度理解为什么是一定

算法核心：每一次看三张牌，若三张票不同则抵消
三张不同的牌抵消可以分为三种情况：

1. 包括A、B
把柱形图里的三个柱形都减一，得到的新柱形图最高的仍然是A、B，不影响最终结果

2. 只包括A、B其中一个，设为A
虽然A减少了1，但是其它数的柱形也减少了1，得到的新柱形图最高的仍然是A、B，不影响最终结果

3. 都不包括A、B
其它数的柱形减少，得到的新柱形图仍然是A、B最高，不影响最终结果

可以看到，三异牌对抗的目的是，每一次对抗都能使其它数的柱形减少，最后留下来的就是结果



###### 2、第二种解释，可以理解为选票法，我觉得这个更好理解

解题思路
做这个题之前可以先看一下169题，投票算法，169题，找一个众数，那就只要一个候选，他是保证一定有一个是众数的，直接投票就好。但是这个题没有保证有一个元素一定出现 n/3以上。

首先我们得明确，**n/k的众数最多只有k-1个，为什么呢？假设有k个众数，n/k * k=n,这k个元素都是众数，还要不同，怎么可能啊。**

那么对于这个题，超过n/3的数最多只能有3-1 = 2 个，我们可以先选出两个候选人A,B。 遍历数组，分三种情况：

候选1：> n/3
候选2：> n/3
其他：< n/3
写代码三步走
1、如果投A（当前元素等于A），则A的票数++;
2、如果投B（当前元素等于B），B的票数++；
3、如果A,B都不投（即当前与A，B都不相等）,那么检查此时A或B的票数是否减为0，如果为0,则当前元素成为新的候选人，选票则是1；如果A,B两个人的票数都不为0，那么A,B两个候选人的票数均减一。

最后会有这么几种可能：有2个大于n/3，有1个大于n/3，有0个大于n/3
遍历结束后选出了两个候选人，但是这两个候选人是否满足>n/3，还需要再遍历一遍数组，找出两个候选人的具体票数，因为题目没有像169题保证一定有。




执行用时：24 ms, 在所有 C++ 提交中击败了93.50%的用户

内存消耗：15.1 MB, 在所有 C++ 提交中击败了50.00%的用户



~~~cpp
    vector<int> majorityElement(vector<int>& nums) {

    int a = INT_MAX, b = INT_MAX;
	int counta = 0, countb = 0;
	for (auto n : nums) {
		if (n == a) counta++;
		else if (n == b) countb++;
		else if (counta == 0) {
			a = n;
			counta = 1;
		}
		else if (countb == 0) {
			b = n;
			countb = 1;
		}
		else {
			counta--;
			countb--;
		}
	}

	vector<int> res;
	counta = 0, countb = 0;
	for (auto n : nums) {
		if (n == a) counta++;
		else if (n == b) countb++;
	}
	if (counta > nums.size() / 3) res.push_back(a);
	if (countb > nums.size() / 3) res.push_back(b);
	return res;
    }
~~~







#### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)   很好的题目 ，看一下二刷2-2的写法，头插法很棒



请判断一个链表是否为回文链表。

**示例 1:**

```
输入: 1->2
输出: false
```

**示例 2:**

```
输入: 1->2->2->1
输出: true
```

**进阶：**
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？



##### 1、数组保存，然后走到数组重点向两边发散，判断数组是否是回文即可

##### 2、O(n)时间  O(1)空间

###### 2-1:速度太慢。。。

执行用时：56 ms, 在所有 C++ 提交中击败了5.57%的用户

内存消耗：14.7 MB, 在所有 C++ 提交中击败了5.72%的用户

~~~cpp

 bool isPalindrome(ListNode* head) {

        if( head == nullptr || head->next == nullptr) return true;

        ListNode *p = head;
        int length = 0;
        while( p!=nullptr ){
            length++;
            p = p ->next;
        } //统计出长度


        ListNode*fast = head,*slow = head, *pre = nullptr;//快慢指针，并且保留slow的前节点
        while( fast != nullptr && fast->next !=nullptr ){
            fast = fast->next->next;
            pre = slow;
            slow = slow->next;
        }

        ListNode *start2=nullptr;
        if( length %2 == 1) { 
            start2= slow->next;
            }
        else{
            start2 = slow;
        }

        pre ->next = nullptr;
        p = start2->next;
        start2->next = nullptr;

        while( p != nullptr ){
            ListNode*node = new ListNode(p->val);
            node->next = start2;
            start2 = node;
            p = p->next;
        }

        int count = 0;
        while(start2!=nullptr && head!=nullptr){
            if(start2->val == head->val)
                count++;
            else
                return false;
            start2 = start2->next;
            head = head->next;
        }

        return count == length/2;

    }
~~~





稍微优化一点点

执行用时：32 ms, 在所有 C++ 提交中击败了72.42%的用户

内存消耗：13.9 MB, 在所有 C++ 提交中击败了5.72%的用户

~~~cpp
    bool isPalindrome(ListNode* head) {

        if( head == nullptr || head->next == nullptr) return true;

        ListNode *p = head;
        int length = 0;
        while( p!=nullptr ){
            length++;
            p = p ->next;
        } //统计出长度


        ListNode*fast = head,*slow = head, *pre = nullptr;//快慢指针，并且保留slow的前节点
        while( fast != nullptr && fast->next !=nullptr ){
            fast = fast->next->next;
            pre = slow;
            slow = slow->next;
        }

        ListNode *start2=nullptr;
        if( length %2 == 1) { 
            start2= slow->next;
            }
        else{
            start2 = slow;
        }
        pre ->next = nullptr;
        p = start2->next;
        start2->next = nullptr;


        ListNode *node = nullptr;
        while( p != nullptr ){//头插法，注意这里，很关键的写法
            node = p;
            p = p->next;//这一步很关键，头插法，要完全断开才可以
            node->next = start2;
            start2 = node;
            
        }


        while(start2!=nullptr && head!=nullptr){
            if(start2->val != head->val)
                return false;
            start2 = start2->next;
            head = head->next;
        }

        return start2 == nullptr && head == nullptr;

    }
~~~



###### 2-2:简练的写法

执行用时：28 ms, 在所有 C++ 提交中击败了90.96%的用户

内存消耗：14 MB, 在所有 C++ 提交中击败了5.72%的用户

~~~cpp
 bool isPalindrome(ListNode* head) {

    if (head == nullptr || head->next == nullptr) return true;//头节点为空 或者只有一个节点的时候是回文链表，这就很奇怪
	ListNode* slow = head, * fast = head, * prev = nullptr;
	while (fast != nullptr) {//find mid node
		slow = slow->next;
		fast = fast->next != nullptr ? fast->next->next : fast->next;
	}

	ListNode* temp = nullptr;
	while (slow != nullptr) {//reverse
		temp = slow->next;
		slow->next = prev;
		prev = slow;
		slow = temp;
	}
    
	while (head && prev) {//check
		if (head->val != prev->val) {
			return false;
		}
		head = head->next;
		prev = prev->next;
	}
	return true;

    }
~~~

~~~cpp
bool isPalindrome(ListNode* head) {

    if (head == nullptr || head->next == nullptr) return true;//为空或者只有一个节点时，直接判断为true
	ListNode* slow = head, * fast = head;
	while (fast != nullptr) {//首先找到中间节点
		slow = slow->next;
        if(fast->next != nullptr)//因为链表长度可能是奇数或偶数，所以需要进行判断
            fast = fast->next->next;
        else
             fast = fast->next;
		
	}

    
	ListNode* temp = nullptr,* pre = nullptr;//pre始终保持后续链表的头部，temp节点则作为中间零时替换的节点
	while (slow != nullptr) {//利用头插法，将当前节点与后续链表断链处理，反转后半部分的链表
		temp = slow->next;
		slow->next = pre;//建立连接
		pre = slow;//pre始终作为后续链表的头部
		slow = temp;
	}
    
	while (head !=nullptr && pre != nullptr) {//同步进行比较
		if (head->val != pre->val) {//有不一样的，直接false了
			return false;
		}
		head = head->next;//head向下走
		pre = pre->next;//pre节点也向下走
	}
	return true;
    }
~~~







##### 二刷：

执行用时：28 ms, 在所有 C++ 提交中击败了91.68%的用户

内存消耗：13.8 MB, 在所有 C++ 提交中击败了72.57%的用户

~~~cpp
    bool isPalindrome(ListNode* head) {

        if(head == nullptr || head->next == nullptr) return true;
        ListNode* fast = head, *slow = head;
        while(fast != nullptr){
            fast = fast->next == nullptr?nullptr:fast->next->next;
            slow = slow->next;
        }
        ListNode *pre = nullptr,*temp = slow;
        while(slow != nullptr){
            temp = slow->next;
            slow->next = pre;
            pre = slow;
            slow = temp;
        }

        while(pre != nullptr){
            if(head->val != pre->val)
                return false;
            head = head->next;
            pre = pre->next;

        }

        return true;
    }
~~~



#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)  好题



给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/binarytree.png)

 

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

 

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。



##### 1、看的讲解，仔细想一下，是要分情况讨论的，值得再刷

执行用时：20 ms, 在所有 C++ 提交中击败了93.42%的用户

内存消耗：14.3 MB, 在所有 C++ 提交中击败了100.00%的用户

~~~cpp
TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
	// LCA 问题
    /*注意p,q必然存在树内, 且所有节点的值唯一!!!
    递归思想, 对以root为根的(子)树进行查找p和q, 如果root == null || p == root || q == root 直接返回root
    表示对于当前树的查找已经完毕, 否则对左右子树进行查找, 根据左右子树的返回值判断:
    1. 左右子树的返回值都不为null, 由于值唯一左右子树的返回值就是p和q, 此时root为LCA
    2. 如果左右子树返回值只有一个不为null, 说明只有p和q存在与左或右子树中, 最先找到的那个节点为LCA
    3. 左右子树返回值均为null, p和q均不在树中, 返回null*/
	if (root == nullptr) {
		return root;
	}
	if (p == root || q == root) {
		return root;
	}
	TreeNode *left = lowestCommonAncestor(root->left, p, q);
	TreeNode *right = lowestCommonAncestor(root->right, p, q);
	if (left != nullptr && right != nullptr) {
		return root;
	}
	else if (left != nullptr) {
		return left;
	}
	else if (right != nullptr) {
		return right;
	}

	return nullptr;
}
~~~







#### [238. 除自身以外数组的乘积](https://leetcode-cn.com/problems/product-of-array-except-self/)



给你一个长度为 *n* 的整数数组 `nums`，其中 *n* > 1，返回输出数组 `output` ，其中 `output[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

 

**示例:**

```
输入: [1,2,3,4]
输出: [24,12,8,6]
```

 

**提示：**题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

**说明:** 请**不要使用除法，**且在 O(*n*) 时间复杂度内完成此题。

**进阶：**
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组**不被视为**额外空间。）

通过次数70,300提交次数

##### 1、借助左右两个数组来做

执行用时：20 ms, 在所有 C++ 提交中击败了87.36%的用户

内存消耗：15.6 MB, 在所有 C++ 提交中击败了14.29%的用户



~~~cpp
vector<int> productExceptSelf(vector<int>& nums) {

	int len = nums.size();
	vector<int> left (len, 1),right(len, 1);// left right数组分别保存当前点，左边所有数值的乘积以及右边所有数字的成绩
	for (int i = 1; i < len; ++i) {
		left[i] = left[i - 1] * nums[i - 1];
	}

	for (int i = len - 2; i >= 0; --i) {
		right[i] = right[i + 1] * nums[i + 1];
	}

	for (int i = 0; i < len; ++i)
		left[i] *= right[i];

	return left;
}
~~~





##### 2、将两个数组简化为left right两个数

执行用时：16 ms, 在所有 C++ 提交中击败了97.91%的用户

内存消耗：15.3 MB, 在所有 C++ 提交中击败了14.29%的用户

~~~cpp
vector<int> productExceptSelf(vector<int>& nums) {

	int len = nums.size(),left = 1,right = 1;
	vector<int> out(len, 1);
	for (int i = 0; i < len; ++i) {
		
		out[i] *= left;
		left *= nums[i];
	}

	for (int i = len - 1; i >= 0; --i) {
		
		out[i] = out[i] * right;
		right *= nums[i];
	}

	return out;
}
~~~





###### 2-2将两个循环合并为一个循环

执行用时：16 ms, 在所有 C++ 提交中击败了97.91%的用户

内存消耗：15.4 MB, 在所有 C++ 提交中击败了14.29%的用户

~~~cpp
vector<int> productExceptSelf(vector<int>& nums) {

	int len = nums.size(),left = 1,right = 1;
	vector<int> out(len, 1);
	for (int i = 0; i < len; ++i) {
		
		out[i] *= left;
		left *= nums[i];
		
		out[len - 1 - i] = out[len - 1 - i] * right;
		right *= nums[len - 1 - i];
	}

	return out;
}
~~~





#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)  挺好的题



给定一个数组 *nums*，有一个大小为 *k* 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 *k* 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

**进阶：**

你能在线性时间复杂度内解决此题吗？

 

**示例:**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

 

**提示：**

- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`
- `1 <= k <= nums.length`



##### 1、单调队列的做法，模板之一

执行用时：116 ms, 在所有 C++ 提交中击败了27.53%的用户

内存消耗：28.1 MB, 在所有 C++ 提交中击败了83.90%的用户

~~~cpp
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {

    vector<int> result;
	deque<int> dq;

	for (int i = 0; i < nums.size(); i++) {

		if (!dq.empty() && dq.front() == i - k) dq.pop_front();//当当前窗口的最大值是上一个窗口的开始值的时候，要把上个窗口的最大值去掉，
		//比如 3，2，1，2，当走到第二个2的时候，最大值还是上一个窗口的开始值

		while (!dq.empty() && nums[i] > nums[dq.back()]) dq.pop_back();//维持一个单调递增的队列，队首始终是最大的，
		//队尾最小，所以新元素入队时要从队尾开始比较

		dq.push_back(i);//当前元素入双端队列

		if (i >= k - 1) result.push_back(nums[dq.front()]);//超过 k-1后，每次都取最前端的元素，因为最前端是最大元素的索引
	}

	return std::move(result);
    }
~~~









#### [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)



给定一个范围在 1 ≤ a[i] ≤ *n* ( *n* = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, *n*] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

**示例:**

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[5,6]
```



##### 1、常规做法就是哈希表，略

##### 2、与offer中数组中重复的数字很像的一道题

执行用时：116 ms, 在所有 C++ 提交中击败了79.95%的用户

内存消耗：32.1 MB, 在所有 C++ 提交中击败了93.07%的用户



~~~cpp
 vector<int> findDisappearedNumbers(vector<int>& nums) {

	int len = nums.size();
	for (int i = 0; i < len; i++) {
		int index = (nums[i] - 1) % len;
		nums[index] += len;//将数字放在他应该在的位置上，并且加上 len 作为标记，那么所有小于len的元素的索引就是没出现的了
	}

	//for (auto a : nums)
	//	cout << a << " ";
	//cout << endl;


	vector<int> res;
	for (int i = 0; i < len; i++) {
		if (nums[i] <= len)
			res.push_back(i + 1);
	}

	//for (auto a : res)
	//	cout << a << " ";
	//cout << endl;

	return res;

        
    }
~~~





使用std::move（） 改进一下：

执行用时：108 ms, 在所有 C++ 提交中击败了94.79%的用户

内存消耗：32.1 MB, 在所有 C++ 提交中击败了86.80%的用户

~~~cpp
    vector<int> findDisappearedNumbers(vector<int>& nums) {

	int len = nums.size();
	for (int i = 0; i < len; i++) {
		int index = (nums[i] - 1) % len;
		nums[index] += len;//将数字放在他应该在的位置上，并且加上 len 作为标记，那么所有小于len的元素的索引就是没出现的了
	}

	vector<int> res;
	for (int i = 0; i < len; i++) {
		if (nums[i] <= len)
			res.push_back(i + 1);
	}

	return std::move(res);

        
    }
~~~





##### 3、抽屉算法，还是第二种比较好理解一点

执行用时：104 ms, 在所有 C++ 提交中击败了97.57%的用户

内存消耗：32.3 MB, 在所有 C++ 提交中击败了44.30%的用户

~~~cpp
    vector<int> findDisappearedNumbers(vector<int>& nums) {

	int len = nums.size();
	int i = 0;
	while (i < len) {
		if (nums[nums[i] - 1] != nums[i]) {
			swap(nums[i], nums[nums[i] - 1]);
		}
		else {
			i++;
		}
	/*	cout << i << endl;
		for (auto a : nums)
			cout << a << " ";
		cout << endl;*/
	}




	vector<int> ret;
	for (int i = 0; i < len; i++) {
		if (i + 1 != nums[i]) {
			ret.push_back(i + 1);
		}
	}


	//for (auto a : ret)
	//	cout << a << " ";
	//cout << endl;

	return ret;

        
    }
~~~





#### [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)



给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。

 

**例如：**

```
输入: 原始二叉搜索树:
              5
            /   \
           2     13

输出: 转换为累加树:
             18
            /   \
          20     13
```

 

**注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同

##### 1、后序遍历的变种，递归写法



执行用时：68 ms, 在所有 C++ 提交中击败了68.69%的用户

内存消耗：33.3 MB, 在所有 C++ 提交中击败了75.00%的用户



真的想多了

~~~cpp
    void convertBST(TreeNode * root,int &sum){
        
        if(root == nullptr) return;
        convertBST(root->right,sum);
        root->val += sum;
        sum = root->val;
        convertBST(root->left,sum);

    }
    TreeNode* convertBST(TreeNode* root) {

    if(root == nullptr) return root;
    int sum = 0;
    convertBST(root,sum);
    return root;
    }
~~~



##### 2、迭代写法，后序遍历 栈，变菜不少，要注意了，真的变菜不少了

执行用时：72 ms, 在所有 C++ 提交中击败了52.11%的用户

内存消耗：33.6 MB, 在所有 C++ 提交中击败了25.77%的用户



~~~cpp
  TreeNode* convertBST(TreeNode* root) {

    if(root == nullptr) return root;
    int sum = 0;
    stack<TreeNode*> st;
    TreeNode * node = root;
    while(!st.empty() || node != nullptr){
        while(node != nullptr){

            st.push(node);
            node = node->right;
        }
        node = st.top();
        st.pop();
        node->val +=sum;
        sum = node->val;
        node = node->left == nullptr ? nullptr : node->left;
    }
    return root;
    }
~~~







#### [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

难度简单406收藏分享切换为英文关注反馈

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。

**示例 1:**

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

**注意:** 合并必须从两个树的根节点开始。



##### 1、递归

执行用时：68 ms, 在所有 C++ 提交中击败了87.61%的用户

内存消耗：33.1 MB, 在所有 C++ 提交中击败了8.70%的用户

~~~cpp
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {

        if(t1==nullptr) return t2;
        if(t2==nullptr) return t1;
        t1->val +=t2->val;
        t1->left = mergeTrees(t1->left,t2->left);
        t1->right = mergeTrees(t1->right,t2->right);
        return t1;
    }
~~~





#### [1353. 最多可以参加的会议数目](https://leetcode-cn.com/problems/maximum-number-of-events-that-can-be-attended/)



给你一个数组 `events`，其中 `events[i] = [startDayi, endDayi]` ，表示会议 `i` 开始于 `startDayi` ，结束于 `endDayi` 。

你可以在满足 `startDayi <= d <= endDayi` 中的任意一天 `d` 参加会议 `i` 。注意，一天只能参加一个会议。

请你返回你可以参加的 **最大** 会议数目。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png)

```
输入：events = [[1,2],[2,3],[3,4]]
输出：3
解释：你可以参加所有的三个会议。
安排会议的一种方案如上图。
第 1 天参加第一个会议。
第 2 天参加第二个会议。
第 3 天参加第三个会议。
```

**示例 2：**

```
输入：events= [[1,2],[2,3],[3,4],[1,2]]
输出：4
```

**示例 3：**

```
输入：events = [[1,4],[4,4],[2,2],[3,4],[1,1]]
输出：4
```

**示例 4：**

```
输入：events = [[1,100000]]
输出：1
```

**示例 5：**

```
输入：events = [[1,1],[1,2],[1,3],[1,4],[1,5],[1,6],[1,7]]
输出：7
```

 

**提示：**

- `1 <= events.length <= 10^5`
- `events[i].length == 2`
- `1 <= events[i][0] <= events[i][1] <= 10^5`





##### 1、解释

~~~cpp
方法：按照结束时间排序，然后依次对每个会议选择能开始的最早时间，与此同时用visited数组记住某一天是否已被使用过；

原理：结束时间相同，从最早开始时间开始选择，选完即止； 结束时间排在后面的，如果开始时间与排在前面的相同，选择参加前面的会议，因为后面的开始时间可选范围较大，如果开始时间比前面的慢，同样满足

缺陷：如果存在某个会议时间是【1,100000】且会议个数为100000，则会导致超时，但测试用例中没有出现

class Solution {
public:
    int maxEvents(vector<vector<int>>& events) {
        sort(events.begin(), events.end(), [](vector<int>& a, vector<int>& b) {
            if (a[1] != b[1]) return a[1] < b[1];
            return a[0] < b[0];
        });
        int res = 0;
        bool visited[100010];
        for (int i = 0; i < 100010; ++i) visited[i] = false;
        for (int i = 0; i < events.size(); ++i) {
            for (int j = events[i][0]; j <= events[i][1]; ++j) {
                if (!visited[j]) {
                    visited[j] = true;
                    ++res;
                    break;
                }
            }
        }
        return res;
    }
};
~~~





#### [1498. 满足条件的子序列数目](https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/) 很好的题目



给你一个整数数组 `nums` 和一个整数 `target` 。

请你统计并返回 `nums` 中能满足其最小元素与最大元素的 **和** 小于或等于 `target` 的 **非空** 子序列的数目。

由于答案可能很大，请将结果对 10^9 + 7 取余后返回。

 

**示例 1：**

```
输入：nums = [3,5,6,7], target = 9
输出：4
解释：有 4 个子序列满足该条件。
[3] -> 最小元素 + 最大元素 <= target (3 + 3 <= 9)
[3,5] -> (3 + 5 <= 9)
[3,5,6] -> (3 + 6 <= 9)
[3,6] -> (3 + 6 <= 9)
```

**示例 2：**

```
输入：nums = [3,3,6,8], target = 10
输出：6
解释：有 6 个子序列满足该条件。（nums 中可以有重复数字）
[3] , [3] , [3,3], [3,6] , [3,6] , [3,3,6]
```

**示例 3：**

```
输入：nums = [2,3,3,4,6,7], target = 12
输出：61
解释：共有 63 个非空子序列，其中 2 个不满足条件（[6,7], [7]）
有效序列总数为（63 - 2 = 61）
```

**示例 4：**

```
输入：nums = [5,2,4,1,7,6,8], target = 16
输出：127
解释：所有非空子序列都满足条件 (2^7 - 1) = 127
```

 

**提示：**

- `1 <= nums.length <= 10^5`
- `1 <= nums[i] <= 10^6`
- `1 <= target <= 10^6`

##### 1、排序+ 双指针 + 数据预处理

执行用时：412 ms, 在所有 C++ 提交中击败了79.43%的用户

内存消耗：50.1 MB, 在所有 C++ 提交中击败了100.00%的用户



1.算组合数需要多次算 2 的幂，所以直接把幂运算的结果存在数组 v 里
2.求子序列不必保持数组顺序，先把数据排序，方便下一步
3.滑动窗口，先固定左边界，然后找右边界，右边界值尽量大且满足左边界值 + 右边界值 < target，该区间的组合数为 2 的 n-1 次幂，n 为区间元素个数





```c++
    int numSubseq(vector<int>& nums, int target) {
	int mod = 1e9 + 7;
	sort(nums.begin(), nums.end());
	int n = nums.size(), res = 0;
	vector<int>pw(n,0);
	pw[0] = 1;
	for (int i = 1; i < n; i++)
	{
		pw[i] = (pw[i - 1] * 2) % mod;
	}
	for (int i = 0, j = n - 1; i < n; i++)
	{
		while (i <= j && nums[i] + nums[j] > target) j--;
		if (i > j) break;
		res = (res + pw[j - i]) % mod;//固定住底下一位，最多就p[j-i]种，
		//比如 i=1 j =2，就两种情况 一是nums[i]，二是nums[i]和nums[j] ，所以是pw[j-i]
	}
	return res;
    }
```



解析：https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/solution/man-zu-tiao-jian-de-zi-xu-lie-shu-mu-by-leetcode-s/

